Below is an approach that gives your end-users a single ~/.tauri-theme.toml (or any path you choose) that all of your Tauri-React-Tailwind apps can understand at run-time, without forcing you to rebuild or re-bundle just to tweak a colour.

⸻

1.  Describe the theme in TOML

# ~/.tauri-theme.toml
[colors]
primary            = "#1e3a8a"   # buttons, links, accents
primary_fg         = "#ffffff"   # text on primary
background         = "#f9fafb"
surface            = "#ffffff"
surface_fg         = "#111827"

[typography]
font_sans          = "Inter, sans-serif"
base_size_rem      = 1           # = 1 rem

Keep the keys flat and predictable; they will become CSS custom-property names.

⸻

2.  Map those keys to CSS variables in Tailwind

Create (or extend) a small CSS file that Tailwind will process:

/* src/styles/theme-vars.css */
@layer base {
  :root {
    --color-primary:        #1e3a8a;   /* default fallback */
    --color-primary-fg:     #ffffff;
    --color-background:     #f9fafb;
    --color-surface:        #ffffff;
    --color-surface-fg:     #111827;

    --font-sans:            'Inter', sans-serif;
    --base-size:            1rem;
  }
}

Then wire those variables into tailwind.config.js once, up-front:

// tailwind.config.js
module.exports = {
  content: ['./src/**/*.{ts,tsx,jsx,html}'],
  theme: {
    extend: {
      colors: {
        primary:          'var(--color-primary)',
        'primary-fg':     'var(--color-primary-fg)',
        background:       'var(--color-background)',
        surface:          'var(--color-surface)',
        'surface-fg':     'var(--color-surface-fg)',
      },
      fontFamily: {
        sans: ['var(--font-sans)'],
      },
      fontSize: {
        base: 'var(--base-size)',
      },
    },
  },
};

Because Tailwind utilities can point at CSS custom properties, any class like bg-primary or text-primary-fg now resolves to whatever the variable holds at run-time  ￼.

⸻

3.  Load and distribute the TOML at run-time (Rust side)

// src-tauri/theme_loader.rs
use std::{fs, path::PathBuf};
use serde::Deserialize;
use tauri::Manager;

#[derive(Deserialize)]
struct Theme {
    colors: Option<Colors>,
    typography: Option<Typography>,
}
#[derive(Deserialize)]
struct Colors {
    primary: Option<String>,
    primary_fg: Option<String>,
    background: Option<String>,
    surface: Option<String>,
    surface_fg: Option<String>,
}
#[derive(Deserialize)]
struct Typography {
    font_sans: Option<String>,
    base_size_rem: Option<f32>,
}

/// Read ~/.tauri-theme.toml, parse, and send to every window.
pub fn broadcast_theme(app_handle: &tauri::AppHandle) -> tauri::Result<()> {
    let mut path = dirs::home_dir().unwrap_or(PathBuf::from("."));
    path.push(".tauri-theme.toml");

    let content = fs::read_to_string(path)?;
    let theme_cfg: Theme = toml::from_str(&content)?;

    app_handle.emit_all("theme-update", theme_cfg)?;
    Ok(())
}

Crate deps: serde, serde_derive, toml, dirs, plus tauri itself.
Tauri already ships an internal TOML parser for its own config  ￼; using the standalone toml crate keeps this loader independent of Tauri’s config schema.

⸻

4.  Apply the variables in React (front-end side)

// src/hooks/useTheme.ts
import { useEffect } from 'react';
import { listen }    from '@tauri-apps/api/event';

type ThemeUpdate = {
  colors?: {
    primary?: string;
    primary_fg?: string;
    background?: string;
    surface?: string;
    surface_fg?: string;
  };
  typography?: {
    font_sans?: string;
    base_size_rem?: number;
  };
};

export function useTheme() {
  useEffect(() => {
    const unlisten = listen<ThemeUpdate>('theme-update', ({ payload }) => {
      const root = document.documentElement;
      payload.colors && Object.entries(payload.colors).forEach(([k, v]) => {
        if (v) root.style.setProperty(`--color-${k.replace('_', '-')}`, v);
      });
      if (payload.typography?.font_sans)
        root.style.setProperty('--font-sans', payload.typography.font_sans);
      if (payload.typography?.base_size_rem)
        root.style.setProperty('--base-size', `${payload.typography.base_size_rem}rem`);
    });
    return () => { unlisten.then(f => f()); };
  }, []);
}

Mount useTheme() once in your app’s root component; every utility class generated by Tailwind will now respect the current values.

Because nothing here re-imports the CSS, a theme change is instant—no flash of unstyled content, and no rebuild.

⸻

5.  (Optional) Hot-reload when the dotfile changes

Add a simple file-watcher in Rust:

use notify::{watcher, RecursiveMode, Watcher};
use std::sync::mpsc::channel;
use std::time::Duration;

// inside setup()
let (tx, rx) = channel();
let mut watcher = watcher(tx, Duration::from_secs(1))?;
watcher.watch(&path, RecursiveMode::NonRecursive)?;

tauri::async_runtime::spawn(async move {
    while let Ok(_event) = rx.recv() {
        broadcast_theme(&app_handle).ok();
    }
});

This keeps the theme in sync as soon as the user saves their TOML.

⸻

6.  Ship the same loader in every Tauri app

Because everything is runtime-driven (CSS variables + broadcast), you can copy-paste theme_loader.rs and the tiny React hook into each app. Users gain a single, dotfile-based system-wide theme, while you avoid maintaining multiple Tailwind builds.

⸻

Why this works well
	•	Tailwind + CSS variables have first-class support for mapping utility classes to custom properties, so you don’t lose the ergonomics of utility-first CSS  ￼.
	•	The TOML file lives where users expect configuration ($HOME), and TOML’s simple table/key syntax is friendlier for non-developers than hand-editing JavaScript configs.
	•	Tauri’s Rust backend can read files anywhere the OS allows—no IPC from the front-end is needed—making it trivial to share one file across many apps  ￼.
	•	All changes are runtime-only; you never re-compile your apps just to tweak colours.

Feel free to adapt the token list (spacing, radii, focus rings, etc.). Once it’s a CSS variable, Tailwind can consume it, and your users can theme every app with one TOML edit.

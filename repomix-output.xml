This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
content/
  lists/
    fruits.md
    groceries.md
  notes/
    test-note2.md
crates/
  lst-cli/
    src/
      cli/
        commands.rs
        mod.rs
      models/
        list.rs
        mod.rs
      storage/
        markdown.rs
        mod.rs
        notes.rs
      config.rs
      lib.rs
      main.rs
    Cargo.toml
  lst-proto/
    src/
      lib.rs
    Cargo.toml
  lst-server/
    src/
      config.rs
      main.rs
      wordlist.rs
    tests/
      integration_tests.rs
    Cargo.toml
  lst-syncd/
    src/
      config.rs
      main.rs
      sync.rs
      watcher.rs
    Cargo.toml
docs/
  INSTALL.md
examples/
  lst.toml
logo/
  logo.svg
.gitignore
Cargo.toml
lst_spec_0.1.excalidraw
README.md
RULES.md
SPEC.md
TODO.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="content/lists/fruits.md">
---
id: c6307640-0da4-4135-96a9-e25eee836214
title: fruits
sharing: []
updated: 2025-04-21T07:37:28.340191Z
---

- [ ] apples ^6OU5c
- [x] oranges ^zNJdV
- [ ] pears ^w5Cdq
</file>

<file path="content/lists/groceries.md">
---
id: 4a2e00bf-5842-4bff-8487-b9672413f0b6
title: groceries
sharing: []
updated: 2025-04-21T07:35:51.705060Z
---

- [x] oat milk ^XMuD1
- [x] bananas ^lkJzl
</file>

<file path="content/notes/test-note2.md">
---
title: "Test Note2"
created: 2025-04-25T22:14:00.760483+00:00
---
</file>

<file path="crates/lst-cli/src/models/list.rs">
use anyhow::Result;
use chrono::{DateTime, Utc};
use rand::distributions::{Alphanumeric, DistString};
use regex::Regex;
use serde::{Deserialize, Serialize};
use std::path::Path;
use uuid::Uuid;

pub fn generate_anchor() -> String {
    // Use 5 random alphanumeric characters
    let anchor = format!(
        "^{}",
        Alphanumeric.sample_string(&mut rand::thread_rng(), 5)
    );
    anchor
}

/// Represents the metadata for a list
#[derive(Debug, Serialize, Deserialize)]
pub struct ListMetadata {
    /// Unique identifier for the list
    #[serde(default = "Uuid::new_v4")]
    pub id: Uuid,

    /// Human-readable title of the list
    pub title: String,

    /// List of users who have access to the list
    #[serde(default)]
    pub sharing: Vec<String>,

    /// When the list was last updated
    #[serde(default = "Utc::now")]
    pub updated: DateTime<Utc>,
}

/// Represents the status of a list item (done or not)
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub enum ItemStatus {
    Todo,
    Done,
}

/// Represents a single item in a list
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct ListItem {
    /// The text content of the item
    pub text: String,

    /// The status of the item (todo or done)
    pub status: ItemStatus,

    /// Unique anchor identifier for the item
    pub anchor: String,
}

/// Represents a complete list with metadata and items
#[derive(Debug, Serialize, Deserialize)]
pub struct List {
    /// Metadata for the list
    #[serde(flatten)]
    pub metadata: ListMetadata,

    /// List items; stored in markdown body, not in frontmatter
    #[serde(default)]
    pub items: Vec<ListItem>,
}

impl List {
    /// Create a new list with the given title
    pub fn new(title: String) -> Self {
        Self {
            metadata: ListMetadata {
                id: Uuid::new_v4(),
                title,
                sharing: vec![],
                updated: Utc::now(),
            },
            items: vec![],
        }
    }

    /// Add a new item to the list
    pub fn add_item(&mut self, text: String) -> &ListItem {
        let anchor = generate_anchor();
        let item = ListItem {
            text,
            status: ItemStatus::Todo,
            anchor,
        };
        self.items.push(item);
        self.metadata.updated = Utc::now();
        self.items.last().unwrap()
    }


    /// Find an item by its anchor
    pub fn find_by_anchor(&self, anchor: &str) -> Option<usize> {
        self.items.iter().position(|item| item.anchor == anchor)
    }

    /// Find an item by exact text match
    pub fn find_by_text(&self, text: &str) -> Option<usize> {
        self.items
            .iter()
            .position(|item| item.text.to_lowercase() == text.to_lowercase())
    }

    /// Find an item by index (0-based)
    pub fn get_by_index(&self, index: usize) -> Option<&ListItem> {
        self.items.get(index)
    }

    /// Get the file name for this list
    pub fn file_name(&self) -> String {
        format!(
            "{}.md",
            self.metadata.title.to_lowercase().replace(' ', "-")
        )
    }
}

/// Check if an anchor is valid
pub fn is_valid_anchor(anchor: &str) -> bool {
    lazy_static::lazy_static! {
        static ref ANCHOR_RE: Regex = Regex::new(r"^\^[A-Za-z0-9-]{4,}$").unwrap();
    }
    ANCHOR_RE.is_match(anchor)
}

/// Find an item by fuzzy matching text
/// Returns a vector of potential matching indices
pub fn fuzzy_find(items: &[ListItem], query: &str, _threshold: f32) -> Vec<usize> {
    // Simple contains matching for now, can be improved later with a fuzzy matching algorithm
    items
        .iter()
        .enumerate()
        .filter(|(_, item)| item.text.to_lowercase().contains(&query.to_lowercase()))
        .map(|(i, _)| i)
        .collect()
}

/// Parse a list from a markdown file
pub fn parse_list_from_markdown(_path: &Path) -> Result<List> {
    // Placeholder implementation, to be expanded
    Err(anyhow::anyhow!("Not implemented yet"))
}

/// Save a list to a markdown file
pub fn save_list_to_markdown(_list: &List, _path: &Path) -> Result<()> {
    // Placeholder implementation, to be expanded
    Err(anyhow::anyhow!("Not implemented yet"))
}
</file>

<file path="crates/lst-cli/src/models/mod.rs">
pub mod list;

pub use list::*;
</file>

<file path="crates/lst-cli/src/storage/markdown.rs">
use anyhow::{Context, Result};
use regex::Regex;
use std::fs;
use std::path::Path;
use crate::models::{List, ListItem, ItemStatus, is_valid_anchor, generate_anchor};

/// Load a list from a markdown file
pub fn load_list(list_name: &str) -> Result<List> {
    let lists_dir = super::get_lists_dir()?;
    let filename = format!("{}.md", list_name);
    let path = lists_dir.join(filename);
    
    if !path.exists() {
        anyhow::bail!("List '{}' does not exist", list_name);
    }
    
    parse_list_from_file(&path)
}

/// Save a list to a markdown file
pub fn save_list(list: &List) -> Result<()> {
    let lists_dir = super::get_lists_dir()?;
    let filename = list.file_name();
    let path = lists_dir.join(filename);
    
    write_list_to_file(list, &path)
}

/// Parse a list from a markdown file
fn parse_list_from_file(path: &Path) -> Result<List> {
    let content = fs::read_to_string(path)
        .with_context(|| format!("Failed to read list file: {}", path.display()))?;
    
    parse_list_from_string(&content, path)
}

/// Write a list to a markdown file
fn write_list_to_file(list: &List, path: &Path) -> Result<()> {
    let content = format_list_as_markdown(list);
    
    fs::write(path, content)
        .with_context(|| format!("Failed to write list file: {}", path.display()))?;
    
    Ok(())
}

/// Parse a list from a markdown string
fn parse_list_from_string(content: &str, path: &Path) -> Result<List> {
    // Split content into frontmatter and body
    let parts: Vec<&str> = content.splitn(3, "---").collect();
    
    if parts.len() < 3 {
        // No frontmatter, create a new list with just the content
        let list_name = path.file_stem()
            .map(|s| s.to_string_lossy().to_string())
            .unwrap_or_else(|| "Untitled List".to_string());
        
        let mut list = List::new(list_name);
        parse_items(&mut list, content);
        return Ok(list);
    }
    
    // Parse frontmatter
    let frontmatter = parts[1].trim();
    let list: List = serde_yaml::from_str(frontmatter)
        .with_context(|| format!("Failed to parse list frontmatter in {}", path.display()))?;
    
    // Parse items from the body
    let mut list = list;
    parse_items(&mut list, parts[2]);
    
    Ok(list)
}

/// Parse list items from markdown content
fn parse_items(list: &mut List, content: &str) {
    // Clear existing items
    list.items.clear();
    
    lazy_static::lazy_static! {
        // Match markdown todo items with optional anchors
        static ref ITEM_RE: Regex = Regex::new(
            r"^- \[([ xX])\] (.*?)(?:  \^([A-Za-z0-9-]{4,}))?$"
        ).unwrap();
    }
    
    for line in content.lines() {
        if let Some(captures) = ITEM_RE.captures(line) {
            let status = if captures[1].trim().is_empty() {
                ItemStatus::Todo
            } else {
                ItemStatus::Done
            };
            
            let text = captures[2].to_string();
            let anchor = captures.get(3)
                .map(|m| format!("^{}", m.as_str()))
                .unwrap_or_else(generate_anchor);
            
            list.items.push(ListItem {
                text,
                status,
                anchor,
            });
        }
    }
}

/// Format a list as markdown
fn format_list_as_markdown(list: &List) -> String {
    // Format frontmatter
    let frontmatter = serde_yaml::to_string(list)
        .unwrap_or_else(|_| "title: Untitled List\n".to_string());
    
    let mut content = format!("---\n{}---\n\n", frontmatter);
    
    // Format items
    for item in &list.items {
        let status = match item.status {
            ItemStatus::Todo => " ",
            ItemStatus::Done => "x",
        };
        
        content.push_str(&format!("- [{}] {}  {}\n", status, item.text, item.anchor));
    }
    
    content
}

/// Create a new list
pub fn create_list(name: &str) -> Result<List> {
    let lists_dir = super::get_lists_dir()?;
    let filename = format!("{}.md", name);
    let path = lists_dir.join(filename);
    
    if path.exists() {
        anyhow::bail!("List '{}' already exists", name);
    }
    
    let list = List::new(name.to_string());
    write_list_to_file(&list, &path)?;
    
    Ok(list)
}

/// Add an item to a list
pub fn add_item(list_name: &str, text: &str) -> Result<ListItem> {
    let mut list = load_list(list_name)?;
    let item = list.add_item(text.to_string());
    let item_clone = item.clone();
    save_list(&list)?;
    
    Ok(item_clone)
}

/// Mark an item as done
pub fn mark_done(list_name: &str, target: &str) -> Result<Vec<ListItem>> {
    let mut list = load_list(list_name)?;
    
    // If there are multiple comma-separated targets, handle each one
    if target.contains(',') {
        let targets: Vec<&str> = target.split(',').map(|s| s.trim()).collect();
        let mut marked_items = Vec::new();
        
        for target in targets {
            if let Ok(item) = mark_item_done(&mut list, target) {
                marked_items.push(item);
            }
        }
        
        if marked_items.is_empty() {
            anyhow::bail!("No matching items found in list '{}'", list_name);
        }
        
        save_list(&list)?;
        return Ok(marked_items);
    }
    
    // Handle single target
    if let Ok(item) = mark_item_done(&mut list, target) {
        save_list(&list)?;
        return Ok(vec![item]);
    }
    
    anyhow::bail!("No item matching '{}' found in list '{}'", target, list_name)
}

/// Mark an item as undone (not completed)
pub fn mark_undone(list_name: &str, target: &str) -> Result<Vec<ListItem>> {
    let mut list = load_list(list_name)?;
    
    // If there are multiple comma-separated targets, handle each one
    if target.contains(',') {
        let targets: Vec<&str> = target.split(',').map(|s| s.trim()).collect();
        let mut marked_items = Vec::new();
        
        for target in targets {
            if let Ok(item) = mark_item_undone(&mut list, target) {
                marked_items.push(item);
            }
        }
        
        if marked_items.is_empty() {
            anyhow::bail!("No matching items found in list '{}'", list_name);
        }
        
        save_list(&list)?;
        return Ok(marked_items);
    }
    
    // Handle single target
    if let Ok(item) = mark_item_undone(&mut list, target) {
        save_list(&list)?;
        return Ok(vec![item]);
    }
    
    anyhow::bail!("No item matching '{}' found in list '{}'", target, list_name)
}

/// Helper function to mark a single item as done
fn mark_item_done(list: &mut List, target: &str) -> Result<ListItem> {
    // Find item and set status
    find_and_set_item_status(list, target, ItemStatus::Done)
}

/// Helper function to mark a single item as undone
fn mark_item_undone(list: &mut List, target: &str) -> Result<ListItem> {
    // Find item and set status
    find_and_set_item_status(list, target, ItemStatus::Todo)
}

/// Helper function to find an item and set its status
fn find_and_set_item_status(list: &mut List, target: &str, status: ItemStatus) -> Result<ListItem> {
    // Try to find the item by anchor first
    if is_valid_anchor(target) {
        if let Some(idx) = list.find_by_anchor(target) {
            list.items[idx].status = status;
            return Ok(list.items[idx].clone());
        }
    }
    
    // Try to find by exact text match
    if let Some(idx) = list.find_by_text(target) {
        list.items[idx].status = status;
        return Ok(list.items[idx].clone());
    }
    
    // Check if it's an index reference (#N)
    if let Some(number_str) = target.strip_prefix('#') {
        if let Ok(idx) = number_str.parse::<usize>() {
            if let Some(item) = list.get_by_index(idx - 1) { // Convert to 0-based
                let item = item.clone();
                let idx = list.find_by_anchor(&item.anchor)
                    .context("Internal error: anchor not found")?;
                list.items[idx].status = status;
                return Ok(item);
            }
        }
    }
    
    // Fallback to fuzzy matching (simple contains for now)
    let matches = crate::models::fuzzy_find(&list.items, target, 0.75);
    match matches.len() {
        0 => anyhow::bail!("No item matching '{}' found", target),
        1 => {
            let idx = matches[0];
            list.items[idx].status = status;
            Ok(list.items[idx].clone())
        },
        _ => anyhow::bail!("Multiple items match '{}', please use a more specific query", target),
    }
}

/// Delete an item from a list
pub fn delete_item(list_name: &str, target: &str) -> Result<Vec<ListItem>> {
    let mut list = load_list(list_name)?;
    
    // If there are multiple comma-separated targets, handle each one
    if target.contains(',') {
        let targets: Vec<&str> = target.split(',').map(|s| s.trim()).collect();
        let mut removed_items = Vec::new();
        
        // Handle each target - we need to process them from highest index to lowest
        // to avoid changing indices during removal
        let mut to_remove = Vec::new();
        
        for target in targets {
            if let Ok((idx, item)) = find_item_for_removal(&list, target) {
                to_remove.push((idx, item.clone()));
            }
        }
        
        // Sort in reverse order by index
        to_remove.sort_by(|a, b| b.0.cmp(&a.0));
        
        // Remove items in reverse index order
        for (idx, _) in &to_remove {
            let removed = list.items.remove(*idx);
            removed_items.push(removed);
        }
        
        if removed_items.is_empty() {
            anyhow::bail!("No matching items found in list '{}'", list_name);
        }
        
        // Reverse back to original order for consistent output
        removed_items.reverse();
        list.metadata.updated = chrono::Utc::now();
        save_list(&list)?;
        return Ok(removed_items);
    }
    
    // Handle single target
    if let Ok((idx, _)) = find_item_for_removal(&list, target) {
        let removed = list.items.remove(idx);
        list.metadata.updated = chrono::Utc::now();
        save_list(&list)?;
        return Ok(vec![removed]);
    }
    
    anyhow::bail!("No item matching '{}' found in list '{}'", target, list_name)
}

/// Helper function to find an item for removal, returning (index, item)
pub fn find_item_for_removal<'a>(list: &'a List, target: &str) -> Result<(usize, &'a ListItem)> {
    // Try to find the item by anchor first
    if is_valid_anchor(target) {
        if let Some(idx) = list.find_by_anchor(target) {
            return Ok((idx, &list.items[idx]));
        }
    }
    
    // Try to find by exact text match
    if let Some(idx) = list.find_by_text(target) {
        return Ok((idx, &list.items[idx]));
    }
    
    // Check if it's an index reference (#N)
    if let Some(number_str) = target.strip_prefix('#') {
        if let Ok(idx) = number_str.parse::<usize>() {
            if let Some(item) = list.get_by_index(idx - 1) { // Convert to 0-based
                let idx = list.find_by_anchor(&item.anchor)
                    .context("Internal error: anchor not found")?;
                return Ok((idx, &list.items[idx]));
            }
        }
    }
    
    // Fallback to fuzzy matching (simple contains for now)
    let matches = crate::models::fuzzy_find(&list.items, target, 0.75);
    match matches.len() {
        0 => anyhow::bail!("No item matching '{}' found", target),
        1 => {
            let idx = matches[0];
            Ok((idx, &list.items[idx]))
        },
        _ => anyhow::bail!("Multiple items match '{}', please use a more specific query", target),
    }
}
</file>

<file path="crates/lst-cli/src/storage/mod.rs">
use crate::config::get_config;
use anyhow::{Context, Result};
use std::fs;
use std::path::{Path, PathBuf};

pub mod markdown;
/// Notes storage (creates and opens individual markdown files under notes/)
pub mod notes;

/// Get the base content directory path
/// Get the base content directory path, using the global cached configuration
pub fn get_content_dir() -> Result<PathBuf> {
    // First check the config (cached)
    let config = get_config();

    // If content_dir is specified in config, use that (supports absolute, relative, or '~' paths)
    if let Some(dir) = config.paths.content_dir.clone() {
        let dir_str = dir.to_string_lossy();
        // Only expand leading '~' to home directory; otherwise use as given
        let expanded: PathBuf = if dir_str.starts_with("~") {
            // Tilde expansion
            if let Some(home) = dirs::home_dir() {
                // Remove '~' and any leading separator, then join to home
                let without_tilde = dir_str
                    .trim_start_matches('~')
                    .trim_start_matches(std::path::MAIN_SEPARATOR);
                home.join(without_tilde)
            } else {
                // Fallback to literal path
                PathBuf::from(&*dir_str)
            }
        } else {
            // Use the path as-is (absolute or relative)
            dir
        };
        if !expanded.exists() {
            fs::create_dir_all(&expanded).with_context(|| {
                format!("Failed to create content directory: {}", expanded.display())
            })?;
        }
        return Ok(expanded);
    }

    // Default to content/ in current directory
    let current_dir = std::env::current_dir().context("Failed to get current directory")?;

    let content_dir = current_dir.join("content");
    if !content_dir.exists() {
        fs::create_dir_all(&content_dir).context("Failed to create content directory")?;
    }

    Ok(content_dir)
}

/// Get the lists directory path
pub fn get_lists_dir() -> Result<PathBuf> {
    let lists_dir = get_content_dir()?.join("lists");
    if !lists_dir.exists() {
        fs::create_dir_all(&lists_dir).context("Failed to create lists directory")?;
    }

    Ok(lists_dir)
}

/// Get the notes directory path
pub fn get_notes_dir() -> Result<PathBuf> {
    let notes_dir = get_content_dir()?.join("notes");
    if !notes_dir.exists() {
        fs::create_dir_all(&notes_dir).context("Failed to create notes directory")?;
    }

    Ok(notes_dir)
}

/// Get the posts directory path
pub fn get_posts_dir() -> Result<PathBuf> {
    let posts_dir = get_content_dir()?.join("posts");
    if !posts_dir.exists() {
        fs::create_dir_all(&posts_dir).context("Failed to create posts directory")?;
    }

    Ok(posts_dir)
}

/// Get the media directory path
pub fn get_media_dir() -> Result<PathBuf> {
    // First check the config (cached)
    let config = get_config();

    // If media_dir is specified in config, use that (supports absolute, relative, or '~' paths)
    if let Some(dir) = config.paths.media_dir.clone() {
        let dir_str = dir.to_string_lossy();
        // Only expand leading '~' to home directory; otherwise use as given
        let expanded: PathBuf = if dir_str.starts_with("~") {
            if let Some(home) = dirs::home_dir() {
                let without_tilde = dir_str
                    .trim_start_matches('~')
                    .trim_start_matches(std::path::MAIN_SEPARATOR);
                home.join(without_tilde)
            } else {
                PathBuf::from(&*dir_str)
            }
        } else {
            dir
        };
        if !expanded.exists() {
            fs::create_dir_all(&expanded).with_context(|| {
                format!("Failed to create media directory: {}", expanded.display())
            })?;
        }
        return Ok(expanded);
    }

    // Default to media/ in content directory
    let media_dir = get_content_dir()?.join("media");
    if !media_dir.exists() {
        fs::create_dir_all(&media_dir).context("Failed to create media directory")?;
    }

    Ok(media_dir)
}

/// List all files in a directory with a specific extension
pub fn list_files(dir: &Path, extension: &str) -> Result<Vec<PathBuf>> {
    let entries = fs::read_dir(dir)
        .with_context(|| format!("Failed to read directory: {}", dir.display()))?;

    let files = entries
        .filter_map(|entry| {
            let entry = entry.ok()?;
            let path = entry.path();
            if path.is_file() && path.extension().map_or(false, |ext| ext == extension) {
                Some(path)
            } else {
                None
            }
        })
        .collect();

    Ok(files)
}

/// List all available lists
pub fn list_lists() -> Result<Vec<String>> {
    let lists_dir = get_lists_dir()?;
    let files = list_files(&lists_dir, "md")?;

    let lists = files
        .iter()
        .filter_map(|path| {
            path.file_stem()
                .map(|stem| stem.to_string_lossy().to_string())
        })
        .collect();

    Ok(lists)
}

/// List all available notes
pub fn list_notes() -> Result<Vec<String>> {
    let notes_dir = get_notes_dir()?;
    let files = list_files(&notes_dir, "md")?;

    let notes = files
        .iter()
        .filter_map(|path| {
            path.file_stem()
                .map(|stem| stem.to_string_lossy().to_string())
        })
        .collect();

    Ok(notes)
}
</file>

<file path="crates/lst-cli/src/storage/notes.rs">
use anyhow::{anyhow, Context, Result};
use chrono::Utc;
use std::path::PathBuf;
use std::fs;

/// Simple slugify: lowercase, replace non-alphanumeric with '-', trim hyphens
fn slugify(title: &str) -> String {
    let slug: String = title
        .to_lowercase()
        .chars()
        .map(|c| {
            if c.is_alphanumeric() {
                c
            } else if c.is_whitespace() {
                '-'
            } else {
                '-'
            }
        })
        .collect();
    slug.trim_matches('-').to_string()
}

/// Return the path for a note with given title (slug.md)
pub fn get_note_path(title: &str) -> Result<PathBuf> {
    let notes_dir = super::get_notes_dir()?;
    let filename = format!("{}.md", slugify(title));
    Ok(notes_dir.join(filename))
}

/// Delete a note with the given title (`slug.md`).
pub fn delete_note(title: &str) -> Result<()> {
    let path = get_note_path(title).context("building note path failed")?;

    if !path.exists() {
        // Return a structured error instead of silently creating a new file.
        anyhow::bail!("note `{}` does not exist", title);
    }

    fs::remove_file(&path).with_context(|| format!("could not delete {}", path.display()))?;

    Ok(())
}

/// Create a new note file with frontmatter and return its path
pub fn create_note(title: &str) -> Result<PathBuf> {
    let path = get_note_path(title)?;
    if path.exists() {
        return Err(anyhow!("Note '{}' already exists", title));
    }
    // Build frontmatter
    let now = Utc::now().to_rfc3339();
    let content = format!("---\ntitle: \"{}\"\ncreated: {}\n---\n\n", title, now);
    fs::write(&path, content)
        .with_context(|| format!("Failed to create note file: {}", path.display()))?;
    Ok(path)
}

/// Ensure note exists and return its path
pub fn load_note(title: &str) -> Result<PathBuf> {
    let path = get_note_path(title)?;
    if !path.exists() {
        return Err(anyhow!("Note '{}' does not exist", title));
    }
    Ok(path)
}
/// Append text to a note (with a newline between old and new text).
/// Creates the note if it does not exist.
pub fn append_to_note(title: &str, text: &str) -> Result<PathBuf> {
    let path = get_note_path(title)?;
    if !path.exists() {
        // Create a new note with frontmatter
        create_note(title)?;
    }
    // Append text with preceding blank line
    let mut file = std::fs::OpenOptions::new()
        .write(true)
        .append(true)
        .open(&path)
        .with_context(|| format!("Failed to open note file for append: {}", path.display()))?;
    // Write a blank line, the text, and a newline
    use std::io::Write;
    writeln!(file, "\n{}", text)
        .with_context(|| format!("Failed to write to note file: {}", path.display()))?;
    Ok(path)
}
</file>

<file path="crates/lst-cli/src/lib.rs">
pub mod config;
pub mod models;
pub mod storage;
</file>

<file path="crates/lst-proto/src/lib.rs">
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SyncMessage {
    pub id: Uuid,
    pub timestamp: DateTime<Utc>,
    pub payload: SyncPayload,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SyncPayload {
    ListUpdate(ListUpdate),
    NoteUpdate(NoteUpdate),
    PostUpdate(PostUpdate),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ListUpdate {
    pub list_name: String,
    pub operation: ListOperation,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ListOperation {
    Add { item: String },
    Remove { item_id: Uuid },
    Complete { item_id: Uuid },
    Uncomplete { item_id: Uuid },
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NoteUpdate {
    pub note_id: String,
    pub content: String,
    pub operation: NoteOperation,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NoteOperation {
    Create,
    Update,
    Delete,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PostUpdate {
    pub post_id: String,
    pub content: String,
    pub operation: PostOperation,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PostOperation {
    Create,
    Update,
    Delete,
    Publish,
    Unpublish,
}
</file>

<file path="crates/lst-proto/Cargo.toml">
[package]
name = "lst-proto"
version = "0.1.0"
description = "Shared types and protocol definitions for lst"
authors = ["Tommy Falkowski"]
edition = "2021"

[dependencies]
serde = { workspace = true }
serde_json = { workspace = true }
uuid = { workspace = true }
chrono = { workspace = true }
</file>

<file path="crates/lst-server/src/wordlist.rs">
pub const WORDS: &[&str] = &[
    "plum", "fire", "bird", "moss", "wave", "dawn", "star", "cloud", "tree", "stone",
    "leaf", "wolf", "drift", "sand", "moon", "sun", "blaze", "crane", "mist", "sage",
    "wind", "fern", "pine", "lake", "hawk", "owl", "iris", "rose", "reed", "twig",
    "snow", "vale", "root", "hill", "gale", "rain", "reed", "rock", "peak", "silk",
    "fawn", "heron", "seal", "beam", "lark", "fox", "dune", "bark", "pearl", "reed"
];
</file>

<file path="crates/lst-server/tests/integration_tests.rs">
use serde_json::json;
use std::time::Duration;
use tokio::time::sleep;

#[tokio::test]
async fn test_health_endpoint() {
    let client = reqwest::Client::new();
    let response = client
        .get("http://127.0.0.1:3001/api/health")
        .send()
        .await;
    
    match response {
        Ok(resp) => {
            assert_eq!(resp.status(), 200);
            let text = resp.text().await.unwrap();
            assert_eq!(text, "OK");
        }
        Err(_) => {
            // Server might not be running - that's okay for now
            println!("Server not running - start with: cargo run --bin lst-server");
        }
    }
}

#[tokio::test]
async fn test_auth_request_endpoint() {
    let client = reqwest::Client::new();
    
    let payload = json!({
        "email": "test@example.com",
        "host": "127.0.0.1:3001"
    });
    
    let response = client
        .post("http://127.0.0.1:3001/api/auth/request")
        .json(&payload)
        .send()
        .await;
    
    match response {
        Ok(resp) => {
            if resp.status().is_success() {
                let json: serde_json::Value = resp.json().await.unwrap();
                assert!(json.get("token").is_some());
                assert!(json.get("qr_png_base64").is_some());
                assert!(json.get("login_url").is_some());
                
                // Verify the login URL format
                let login_url = json["login_url"].as_str().unwrap();
                assert!(login_url.starts_with("lst-login://"));
                assert!(login_url.contains("auth/verify"));
                
                println!("Auth request successful - token: {}", json["token"]);
            } else {
                println!("Auth request failed with status: {}", resp.status());
            }
        }
        Err(_) => {
            println!("Server not running - start with: cargo run --bin lst-server");
        }
    }
}

#[tokio::test]
async fn test_full_auth_flow() {
    let client = reqwest::Client::new();
    
    // Step 1: Request auth token
    let payload = json!({
        "email": "test@example.com", 
        "host": "127.0.0.1:3001"
    });
    
    let auth_response = client
        .post("http://127.0.0.1:3001/api/auth/request")
        .json(&payload)
        .send()
        .await;
    
    match auth_response {
        Ok(resp) if resp.status().is_success() => {
            let auth_json: serde_json::Value = resp.json().await.unwrap();
            let token = auth_json["token"].as_str().unwrap();
            
            // Step 2: Verify the token (should work immediately)
            let verify_payload = json!({
                "email": "test@example.com",
                "token": token
            });
            
            let verify_response = client
                .post("http://127.0.0.1:3001/api/auth/verify")
                .json(&verify_payload)
                .send()
                .await
                .unwrap();
            
            if verify_response.status().is_success() {
                let verify_json: serde_json::Value = verify_response.json().await.unwrap();
                assert!(verify_json.get("jwt").is_some());
                assert_eq!(verify_json["user"], "test@example.com");
                
                println!("Full auth flow successful - JWT received");
            } else {
                println!("Token verification failed with status: {}", verify_response.status());
            }
        }
        _ => {
            println!("Server not running - start with: cargo run --bin lst-server -- --config test-server.toml");
        }
    }
}

#[tokio::test] 
async fn test_invalid_token_rejection() {
    let client = reqwest::Client::new();
    
    let verify_payload = json!({
        "email": "test@example.com",
        "token": "INVALID-TOKEN-123"
    });
    
    let response = client
        .post("http://127.0.0.1:3001/api/auth/verify")
        .json(&verify_payload)
        .send()
        .await;
    
    match response {
        Ok(resp) => {
            assert_eq!(resp.status(), 401); // Unauthorized
            println!("Invalid token correctly rejected");
        }
        Err(_) => {
            println!("Server not running - start with: cargo run --bin lst-server");
        }
    }
}
</file>

<file path="crates/lst-server/Cargo.toml">
[package]
name = "lst-server"
version = "0.1.0"
description = "Personal lists & notes app server"
authors = ["Tommy Falkowski"]
edition = "2021"

[[bin]]
name = "lst-server"
path = "src/main.rs"

[dependencies]
# CLI
clap = { workspace = true }

# Server framework
axum = { workspace = true }
hyper = { workspace = true }
tokio = { workspace = true }

# Serialization
serde = { workspace = true }
serde_json = { workspace = true }
toml = { workspace = true }

# Utilities
uuid = { workspace = true }
chrono = { workspace = true }
anyhow = { workspace = true }
thiserror = { workspace = true }
base64 = { workspace = true }
jsonwebtoken = { workspace = true }
urlencoding = { workspace = true }
qrcode = { workspace = true }
image = { workspace = true }
rand = { workspace = true }
lettre = { workspace = true }
dirs = { workspace = true }

# Internal dependencies
lst-proto = { path = "../lst-proto" }

[dev-dependencies]
reqwest = { workspace = true }
</file>

<file path="crates/lst-syncd/src/watcher.rs">
use anyhow::{Context, Result};
use notify::{Config, Event, RecommendedWatcher, RecursiveMode, Watcher};
use std::path::Path;
use tokio::sync::mpsc;

pub struct FileWatcher {
    _watcher: RecommendedWatcher,
    receiver: mpsc::UnboundedReceiver<notify::Result<Event>>,
}

impl FileWatcher {
    pub fn new(content_dir: &Path) -> Result<Self> {
        let (tx, receiver) = mpsc::unbounded_channel();
        
        let mut watcher = RecommendedWatcher::new(
            move |res| {
                if let Err(_) = tx.send(res) {
                    // Channel closed, watcher is being dropped
                }
            },
            Config::default(),
        )
        .context("Failed to create file watcher")?;
        
        watcher
            .watch(content_dir, RecursiveMode::Recursive)
            .with_context(|| format!("Failed to watch directory: {}", content_dir.display()))?;
        
        Ok(Self {
            _watcher: watcher,
            receiver,
        })
    }
    
    pub async fn next_event(&mut self) -> Option<Event> {
        match self.receiver.recv().await {
            Some(Ok(event)) => {
                // Filter out events we don't care about
                match event.kind {
                    notify::EventKind::Create(_) | 
                    notify::EventKind::Modify(_) | 
                    notify::EventKind::Remove(_) => Some(event),
                    _ => None,
                }
            }
            Some(Err(e)) => {
                eprintln!("File watcher error: {}", e);
                None
            }
            None => None,
        }
    }
}
</file>

<file path="docs/INSTALL.md">
# Installation Guide

This guide explains how to install **lst**, the personal lists & notes application, from source.

## Prerequisites

- **Rust toolchain**: Install the latest stable Rust from [rust-lang.org](https://www.rust-lang.org/tools/install).
- **Git**: Required for cloning the repository.

## Building the CLI

1. Clone the repository:

   ```bash
   git clone https://github.com/yourusername/lst.git
   cd lst
   ```

2. Build and install the `lst` CLI:

   ```bash
   cargo install --path .
   ```

   This compiles an optimized release build and places the binary in your Cargo bin directory (usually `~/.cargo/bin`).

3. Verify the installation:

   ```bash
   lst --help
   ```

## Running the Server

The repository also contains a small API server. To build and run it:

```bash
cargo run --bin lst-server
```

## Configuration

Copy the example configuration to your config directory and adjust paths as needed:

```bash
mkdir -p ~/.config/lst
cp examples/lst.toml ~/.config/lst/lst.toml
```

Edit `~/.config/lst/lst.toml` to customize content directories or server settings.

For more details on configuration options see the [README](README.md).
</file>

<file path="logo/logo.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg id="Layer_2" xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 800 800">
  <!-- Generator: Adobe Illustrator 29.5.0, SVG Export Plug-In . SVG Version: 2.1.0 Build 137)  -->
  <defs>
    <style>
      .st0 {
        fill: #fff;
      }
    </style>
  </defs>
  <g>
    <path d="M429.3,288.4c-5.5,0-10-4.5-10-10v-85.9c0-5.5-4.5-10-10-10h-72.2c-5.5,0-10,4.5-10,10v311c0,3.2,2.6,5.8,5.8,5.8h35.9c5.5,0,10,4.5,10,10v88.3c0,5.5,4.5,10,10,10h72.2c5.5,0,10-4.5,10-10v-313.4c0-3.2-2.6-5.8-5.8-5.8h-35.9Z"/>
    <path d="M445.1,182.4c-5.5,0-10,4.5-10,10v74.1c0,3.2,2.6,5.8,5.8,5.8h37.3c5.5,0,10,4.5,10,10v325.2c0,5.5,4.5,10,10,10h72.2c5.5,0,10-4.5,10-10V192.4c0-5.5-4.5-10-10-10h-125.3Z"/>
    <path d="M321.8,525.4c-5.5,0-10-4.5-10-10V192.4c0-5.5-4.5-10-10-10h-72.2c-5.5,0-10,4.5-10,10v415.1c0,5.5,4.5,10,10,10h121.7c5.5,0,10-4.5,10-10v-76.3c0-3.2-2.6-5.8-5.8-5.8h-33.7Z"/>
  </g>
  <rect class="st0" y="-1006" width="800" height="800" rx="50" ry="50"/>
  <g>
    <path d="M429.3-717.6c-5.5,0-10-4.5-10-10v-85.9c0-5.5-4.5-10-10-10h-72.2c-5.5,0-10,4.5-10,10v311c0,3.2,2.6,5.8,5.8,5.8h35.9c5.5,0,10,4.5,10,10v88.3c0,5.5,4.5,10,10,10h72.2c5.5,0,10-4.5,10-10v-313.4c0-3.2-2.6-5.8-5.8-5.8h-35.9Z"/>
    <path d="M445.1-823.5c-5.5,0-10,4.5-10,10v74.1c0,3.2,2.6,5.8,5.8,5.8h37.3c5.5,0,10,4.5,10,10v325.2c0,5.5,4.5,10,10,10h72.2c5.5,0,10-4.5,10-10v-415.1c0-5.5-4.5-10-10-10h-125.3Z"/>
    <path d="M321.8-480.6c-5.5,0-10-4.5-10-10v-323c0-5.5-4.5-10-10-10h-72.2c-5.5,0-10,4.5-10,10v415.1c0,5.5,4.5,10,10,10h121.7c5.5,0,10-4.5,10-10v-76.3c0-3.2-2.6-5.8-5.8-5.8h-33.7Z"/>
  </g>
  <g>
    <path class="st0" d="M-575.4,288.4c-5.5,0-10-4.5-10-10v-85.9c0-5.5-4.5-10-10-10h-72.2c-5.5,0-10,4.5-10,10v311c0,3.2,2.6,5.8,5.8,5.8h35.9c5.5,0,10,4.5,10,10v88.3c0,5.5,4.5,10,10,10h72.2c5.5,0,10-4.5,10-10v-313.4c0-3.2-2.6-5.8-5.8-5.8h-35.9Z"/>
    <path class="st0" d="M-559.6,182.4c-5.5,0-10,4.5-10,10v74.1c0,3.2,2.6,5.8,5.8,5.8h37.3c5.5,0,10,4.5,10,10v325.2c0,5.5,4.5,10,10,10h72.2c5.5,0,10-4.5,10-10V192.4c0-5.5-4.5-10-10-10h-125.3Z"/>
    <path class="st0" d="M-682.9,525.4c-5.5,0-10-4.5-10-10V192.4c0-5.5-4.5-10-10-10h-72.2c-5.5,0-10,4.5-10,10v415.1c0,5.5,4.5,10,10,10h121.7c5.5,0,10-4.5,10-10v-76.3c0-3.2-2.6-5.8-5.8-5.8h-33.7Z"/>
  </g>
  <rect x="-1004.7" y="-1006" width="800" height="800" rx="50" ry="50"/>
  <g>
    <path class="st0" d="M-575.4-717.6c-5.5,0-10-4.5-10-10v-85.9c0-5.5-4.5-10-10-10h-72.2c-5.5,0-10,4.5-10,10v311c0,3.2,2.6,5.8,5.8,5.8h35.9c5.5,0,10,4.5,10,10v88.3c0,5.5,4.5,10,10,10h72.2c5.5,0,10-4.5,10-10v-313.4c0-3.2-2.6-5.8-5.8-5.8h-35.9Z"/>
    <path class="st0" d="M-559.6-823.5c-5.5,0-10,4.5-10,10v74.1c0,3.2,2.6,5.8,5.8,5.8h37.3c5.5,0,10,4.5,10,10v325.2c0,5.5,4.5,10,10,10h72.2c5.5,0,10-4.5,10-10v-415.1c0-5.5-4.5-10-10-10h-125.3Z"/>
    <path class="st0" d="M-682.9-480.6c-5.5,0-10-4.5-10-10v-323c0-5.5-4.5-10-10-10h-72.2c-5.5,0-10,4.5-10,10v415.1c0,5.5,4.5,10,10,10h121.7c5.5,0,10-4.5,10-10v-76.3c0-3.2-2.6-5.8-5.8-5.8h-33.7Z"/>
  </g>
</svg>
</file>

<file path="lst_spec_0.1.excalidraw">
{
  "type": "excalidraw",
  "version": 2,
  "source": "http://localhost:5001",
  "elements": [
    {
      "id": "9OvhvTeKYFToXOy807lID",
      "type": "rectangle",
      "x": -131.63671875,
      "y": 416.5,
      "width": 1134.119140625,
      "height": 340,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [
        "ivN84yXvXBIxO5t7lPMbr"
      ],
      "frameId": null,
      "index": "a0",
      "roundness": null,
      "seed": 1136291411,
      "version": 4,
      "versionNonce": 1042846813,
      "isDeleted": false,
      "boundElements": [
        {
          "type": "text",
          "id": "hfcrxknXEuG5wDVJQ6cY1"
        }
      ],
      "updated": 1745133279536,
      "link": null,
      "locked": false
    },
    {
      "id": "hfcrxknXEuG5wDVJQ6cY1",
      "type": "text",
      "x": 374.5429000854492,
      "y": 421.5,
      "width": 121.75990295410156,
      "height": 25,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [
        "ivN84yXvXBIxO5t7lPMbr"
      ],
      "frameId": null,
      "index": "a1",
      "roundness": null,
      "seed": 94317555,
      "version": 6,
      "versionNonce": 1293938867,
      "isDeleted": false,
      "boundElements": [],
      "updated": 1745133279537,
      "link": null,
      "locked": false,
      "text": "Server (LXC)",
      "fontSize": 20,
      "fontFamily": 5,
      "textAlign": "center",
      "verticalAlign": "top",
      "containerId": "9OvhvTeKYFToXOy807lID",
      "originalText": "Server (LXC)",
      "autoResize": true,
      "lineHeight": 1.25
    },
    {
      "id": "-7Kw66fjXXrJk8OqwJASY",
      "type": "rectangle",
      "x": 249.1015625,
      "y": 441.5,
      "width": 196.09375,
      "height": 44,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [
        "ivN84yXvXBIxO5t7lPMbr"
      ],
      "frameId": null,
      "index": "a2",
      "roundness": null,
      "seed": 1398486419,
      "version": 11,
      "versionNonce": 161146877,
      "isDeleted": false,
      "boundElements": [
        {
          "type": "text",
          "id": "9KwJpQOhQ3mZq-ff2xcLj"
        },
        {
          "id": "_IlAyMorExiezo4chTlm_",
          "type": "arrow"
        },
        {
          "id": "s6JQb4oR0oLBrpbYWJOmT",
          "type": "arrow"
        },
        {
          "id": "0s-3dCJ9upp4lNbKMFRrC",
          "type": "arrow"
        },
        {
          "id": "g2Je-ZuYkGeXjZhau_jRs",
          "type": "arrow"
        },
        {
          "id": "4iIouzj--syOX6DIIgFh1",
          "type": "arrow"
        },
        {
          "id": "qzVRqOcD8KLqj-H_lMpwh",
          "type": "arrow"
        }
      ],
      "updated": 1745133279537,
      "link": null,
      "locked": false
    },
    {
      "id": "9KwJpQOhQ3mZq-ff2xcLj",
      "type": "text",
      "x": 265.1684875488281,
      "y": 451,
      "width": 163.95989990234375,
      "height": 25,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [
        "ivN84yXvXBIxO5t7lPMbr"
      ],
      "frameId": null,
      "index": "a3",
      "roundness": null,
      "seed": 1277496115,
      "version": 6,
      "versionNonce": 535126611,
      "isDeleted": false,
      "boundElements": [],
      "updated": 1745133279537,
      "link": null,
      "locked": false,
      "text": "Core API (Axum)",
      "fontSize": 20,
      "fontFamily": 5,
      "textAlign": "center",
      "verticalAlign": "middle",
      "containerId": "-7Kw66fjXXrJk8OqwJASY",
      "originalText": "Core API (Axum)",
      "autoResize": true,
      "lineHeight": 1.25
    },
    {
      "id": "bjeLMExsMMxjJwoJb3uh9",
      "type": "rectangle",
      "x": 246.01953125,
      "y": 564.5,
      "width": 202.2578125,
      "height": 44,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [
        "ivN84yXvXBIxO5t7lPMbr"
      ],
      "frameId": null,
      "index": "a4",
      "roundness": null,
      "seed": 1684221139,
      "version": 7,
      "versionNonce": 1163321437,
      "isDeleted": false,
      "boundElements": [
        {
          "type": "text",
          "id": "ZO_suqlTJgeupkeOAyGVb"
        },
        {
          "id": "qzVRqOcD8KLqj-H_lMpwh",
          "type": "arrow"
        },
        {
          "id": "HxqUKPGRpiI6SSXMywSPq",
          "type": "arrow"
        }
      ],
      "updated": 1745133279537,
      "link": null,
      "locked": false
    },
    {
      "id": "ZO_suqlTJgeupkeOAyGVb",
      "type": "text",
      "x": 256.8184814453125,
      "y": 574,
      "width": 180.659912109375,
      "height": 25,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [
        "ivN84yXvXBIxO5t7lPMbr"
      ],
      "frameId": null,
      "index": "a5",
      "roundness": null,
      "seed": 1068243571,
      "version": 6,
      "versionNonce": 139173875,
      "isDeleted": false,
      "boundElements": [],
      "updated": 1745133279537,
      "link": null,
      "locked": false,
      "text": "CRDT + Git Store",
      "fontSize": 20,
      "fontFamily": 5,
      "textAlign": "center",
      "verticalAlign": "middle",
      "containerId": "bjeLMExsMMxjJwoJb3uh9",
      "originalText": "CRDT + Git Store",
      "autoResize": true,
      "lineHeight": 1.25
    },
    {
      "id": "-SHMJRT98xSJf9F68VBM7",
      "type": "rectangle",
      "x": -96.63671875,
      "y": 687.5,
      "width": 136.484375,
      "height": 44,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [
        "ivN84yXvXBIxO5t7lPMbr"
      ],
      "frameId": null,
      "index": "a6",
      "roundness": null,
      "seed": 1254511635,
      "version": 5,
      "versionNonce": 733269181,
      "isDeleted": false,
      "boundElements": [
        {
          "type": "text",
          "id": "jUmlYu_AeYWbngD4an096"
        }
      ],
      "updated": 1745133279537,
      "link": null,
      "locked": false
    },
    {
      "id": "jUmlYu_AeYWbngD4an096",
      "type": "text",
      "x": -84.42449951171875,
      "y": 697,
      "width": 112.0599365234375,
      "height": 25,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [
        "ivN84yXvXBIxO5t7lPMbr"
      ],
      "frameId": null,
      "index": "a7",
      "roundness": null,
      "seed": 363354547,
      "version": 6,
      "versionNonce": 811149715,
      "isDeleted": false,
      "boundElements": [],
      "updated": 1745133279537,
      "link": null,
      "locked": false,
      "text": "SMTP relay",
      "fontSize": 20,
      "fontFamily": 5,
      "textAlign": "center",
      "verticalAlign": "middle",
      "containerId": "-SHMJRT98xSJf9F68VBM7",
      "originalText": "SMTP relay",
      "autoResize": true,
      "lineHeight": 1.25
    },
    {
      "id": "2sNxTlJSijpjhHKB_gTep",
      "type": "rectangle",
      "x": 248.97265625,
      "y": 687.5,
      "width": 196.3515625,
      "height": 44,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [
        "ivN84yXvXBIxO5t7lPMbr"
      ],
      "frameId": null,
      "index": "a8",
      "roundness": null,
      "seed": 1836624723,
      "version": 6,
      "versionNonce": 2086022429,
      "isDeleted": false,
      "boundElements": [
        {
          "type": "text",
          "id": "Ow3KOSBbCtKmr5qz9QWgj"
        },
        {
          "id": "HxqUKPGRpiI6SSXMywSPq",
          "type": "arrow"
        }
      ],
      "updated": 1745133279537,
      "link": null,
      "locked": false
    },
    {
      "id": "Ow3KOSBbCtKmr5qz9QWgj",
      "type": "text",
      "x": 265.31848907470703,
      "y": 697,
      "width": 163.65989685058594,
      "height": 25,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [
        "ivN84yXvXBIxO5t7lPMbr"
      ],
      "frameId": null,
      "index": "a9",
      "roundness": null,
      "seed": 915261683,
      "version": 6,
      "versionNonce": 1027899187,
      "isDeleted": false,
      "boundElements": [],
      "updated": 1745133279537,
      "link": null,
      "locked": false,
      "text": "Zola static build",
      "fontSize": 20,
      "fontFamily": 5,
      "textAlign": "center",
      "verticalAlign": "middle",
      "containerId": "2sNxTlJSijpjhHKB_gTep",
      "originalText": "Zola static build",
      "autoResize": true,
      "lineHeight": 1.25
    },
    {
      "id": "qzVRqOcD8KLqj-H_lMpwh",
      "type": "arrow",
      "x": 347.148875,
      "y": 486,
      "width": 0,
      "height": 72.69999999999999,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [
        "ivN84yXvXBIxO5t7lPMbr"
      ],
      "frameId": null,
      "index": "aA",
      "roundness": {
        "type": 2
      },
      "seed": 107885203,
      "version": 7,
      "versionNonce": 111968637,
      "isDeleted": false,
      "boundElements": [
        {
          "type": "text",
          "id": "LhVgAqvuGL2ovPdjkqk-j"
        }
      ],
      "updated": 1745133279537,
      "link": null,
      "locked": false,
      "points": [
        [
          0,
          0
        ],
        [
          0,
          39
        ],
        [
          0,
          72.69999999999999
        ]
      ],
      "lastCommittedPoint": null,
      "startBinding": {
        "elementId": "-7Kw66fjXXrJk8OqwJASY",
        "focus": -0.000004462151394151831,
        "gap": 1
      },
      "endBinding": {
        "elementId": "bjeLMExsMMxjJwoJb3uh9",
        "focus": 0.000004326161690072419,
        "gap": 5.300000000000011
      },
      "startArrowhead": null,
      "endArrowhead": "arrow",
      "elbowed": false
    },
    {
      "id": "LhVgAqvuGL2ovPdjkqk-j",
      "type": "text",
      "x": 295.9089152832031,
      "y": 512.5,
      "width": 102.47991943359375,
      "height": 25,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [
        "ivN84yXvXBIxO5t7lPMbr"
      ],
      "frameId": null,
      "index": "aB",
      "roundness": null,
      "seed": 2110810163,
      "version": 6,
      "versionNonce": 1769218259,
      "isDeleted": false,
      "boundElements": [],
      "updated": 1745133279537,
      "link": null,
      "locked": false,
      "text": "file events",
      "fontSize": 20,
      "fontFamily": 5,
      "textAlign": "center",
      "verticalAlign": "middle",
      "containerId": "qzVRqOcD8KLqj-H_lMpwh",
      "originalText": "file events",
      "autoResize": true,
      "lineHeight": 1.25
    },
    {
      "id": "HxqUKPGRpiI6SSXMywSPq",
      "type": "arrow",
      "x": 347.148875,
      "y": 609,
      "width": 0,
      "height": 72.69999999999999,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [
        "ivN84yXvXBIxO5t7lPMbr"
      ],
      "frameId": null,
      "index": "aC",
      "roundness": {
        "type": 2
      },
      "seed": 1654319571,
      "version": 7,
      "versionNonce": 804866525,
      "isDeleted": false,
      "boundElements": [
        {
          "type": "text",
          "id": "NeHT-Dr9Zj_wNkupYtmf9"
        }
      ],
      "updated": 1745133279537,
      "link": null,
      "locked": false,
      "points": [
        [
          0,
          0
        ],
        [
          0,
          39
        ],
        [
          0,
          72.69999999999999
        ]
      ],
      "lastCommittedPoint": null,
      "startBinding": {
        "elementId": "bjeLMExsMMxjJwoJb3uh9",
        "focus": -0.000004326161690072419,
        "gap": 1
      },
      "endBinding": {
        "elementId": "2sNxTlJSijpjhHKB_gTep",
        "focus": 0.0000044562925235076346,
        "gap": 5.300000000000011
      },
      "startArrowhead": null,
      "endArrowhead": "arrow",
      "elbowed": false
    },
    {
      "id": "NeHT-Dr9Zj_wNkupYtmf9",
      "type": "text",
      "x": 283.198923828125,
      "y": 635.5,
      "width": 127.89990234375,
      "height": 25,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [
        "ivN84yXvXBIxO5t7lPMbr"
      ],
      "frameId": null,
      "index": "aD",
      "roundness": null,
      "seed": 2044999539,
      "version": 6,
      "versionNonce": 1585352307,
      "isDeleted": false,
      "boundElements": [],
      "updated": 1745133279537,
      "link": null,
      "locked": false,
      "text": "publish posts",
      "fontSize": 20,
      "fontFamily": 5,
      "textAlign": "center",
      "verticalAlign": "middle",
      "containerId": "HxqUKPGRpiI6SSXMywSPq",
      "originalText": "publish posts",
      "autoResize": true,
      "lineHeight": 1.25
    },
    {
      "id": "HowGxm_O4jI_yHjyL2WiL",
      "type": "rectangle",
      "x": -161.453125,
      "y": 272.5,
      "width": 1218.90625,
      "height": 94,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [
        "6WDQUhmdAueqbUmo9Jqmu"
      ],
      "frameId": null,
      "index": "aE",
      "roundness": null,
      "seed": 569561363,
      "version": 5,
      "versionNonce": 961414717,
      "isDeleted": false,
      "boundElements": [
        {
          "type": "text",
          "id": "ukidRnPrF2qc8YkfI5yW5"
        }
      ],
      "updated": 1745133279537,
      "link": null,
      "locked": false
    },
    {
      "id": "ukidRnPrF2qc8YkfI5yW5",
      "type": "text",
      "x": 415.4300308227539,
      "y": 277.5,
      "width": 65.13993835449219,
      "height": 25,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [
        "6WDQUhmdAueqbUmo9Jqmu"
      ],
      "frameId": null,
      "index": "aF",
      "roundness": null,
      "seed": 742209203,
      "version": 6,
      "versionNonce": 1328171027,
      "isDeleted": false,
      "boundElements": [],
      "updated": 1745133279537,
      "link": null,
      "locked": false,
      "text": "Clients",
      "fontSize": 20,
      "fontFamily": 5,
      "textAlign": "center",
      "verticalAlign": "top",
      "containerId": "HowGxm_O4jI_yHjyL2WiL",
      "originalText": "Clients",
      "autoResize": true,
      "lineHeight": 1.25
    },
    {
      "id": "iQN9apfNKViYkllzoh74i",
      "type": "rectangle",
      "x": -126.453125,
      "y": 297.5,
      "width": 115.8203125,
      "height": 44,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [
        "6WDQUhmdAueqbUmo9Jqmu"
      ],
      "frameId": null,
      "index": "aG",
      "roundness": null,
      "seed": 2003429459,
      "version": 6,
      "versionNonce": 1166816925,
      "isDeleted": false,
      "boundElements": [
        {
          "type": "text",
          "id": "qqHC2JXlM7WbSxiU1LkYk"
        },
        {
          "id": "_IlAyMorExiezo4chTlm_",
          "type": "arrow"
        }
      ],
      "updated": 1745133279537,
      "link": null,
      "locked": false
    },
    {
      "id": "qqHC2JXlM7WbSxiU1LkYk",
      "type": "text",
      "x": -117.9829330444336,
      "y": 307,
      "width": 98.87992858886719,
      "height": 25,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [
        "6WDQUhmdAueqbUmo9Jqmu"
      ],
      "frameId": null,
      "index": "aH",
      "roundness": null,
      "seed": 1229940211,
      "version": 6,
      "versionNonce": 1366150579,
      "isDeleted": false,
      "boundElements": [],
      "updated": 1745133279537,
      "link": null,
      "locked": false,
      "text": "lst (Rust)",
      "fontSize": 20,
      "fontFamily": 5,
      "textAlign": "center",
      "verticalAlign": "middle",
      "containerId": "iQN9apfNKViYkllzoh74i",
      "originalText": "lst (Rust)",
      "autoResize": true,
      "lineHeight": 1.25
    },
    {
      "id": "aBqxGZVJYiORTGhK-NqkZ",
      "type": "rectangle",
      "x": 39.3671875,
      "y": 297.5,
      "width": 170.5546875,
      "height": 44,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [
        "6WDQUhmdAueqbUmo9Jqmu"
      ],
      "frameId": null,
      "index": "aI",
      "roundness": null,
      "seed": 1760833427,
      "version": 6,
      "versionNonce": 526736125,
      "isDeleted": false,
      "boundElements": [
        {
          "type": "text",
          "id": "AOkCsHl6KdHpdhVIGqybc"
        },
        {
          "id": "s6JQb4oR0oLBrpbYWJOmT",
          "type": "arrow"
        }
      ],
      "updated": 1745133279537,
      "link": null,
      "locked": false
    },
    {
      "id": "AOkCsHl6KdHpdhVIGqybc",
      "type": "text",
      "x": 53.77458190917969,
      "y": 307,
      "width": 141.73989868164062,
      "height": 25,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [
        "6WDQUhmdAueqbUmo9Jqmu"
      ],
      "frameId": null,
      "index": "aJ",
      "roundness": null,
      "seed": 2022622515,
      "version": 6,
      "versionNonce": 2020581203,
      "isDeleted": false,
      "boundElements": [],
      "updated": 1745133279537,
      "link": null,
      "locked": false,
      "text": "Tauri slim GUI",
      "fontSize": 20,
      "fontFamily": 5,
      "textAlign": "center",
      "verticalAlign": "middle",
      "containerId": "aBqxGZVJYiORTGhK-NqkZ",
      "originalText": "Tauri slim GUI",
      "autoResize": true,
      "lineHeight": 1.25
    },
    {
      "id": "5DkfYx4Cj8vJKyUneZSqn",
      "type": "rectangle",
      "x": 259.921875,
      "y": 297.5,
      "width": 174.453125,
      "height": 44,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [
        "6WDQUhmdAueqbUmo9Jqmu"
      ],
      "frameId": null,
      "index": "aK",
      "roundness": null,
      "seed": 260417235,
      "version": 6,
      "versionNonce": 1062925149,
      "isDeleted": false,
      "boundElements": [
        {
          "type": "text",
          "id": "aPSmAVYXwuJ70klL9uhi-"
        },
        {
          "id": "0s-3dCJ9upp4lNbKMFRrC",
          "type": "arrow"
        }
      ],
      "updated": 1745133279537,
      "link": null,
      "locked": false
    },
    {
      "id": "aPSmAVYXwuJ70klL9uhi-",
      "type": "text",
      "x": 278.3384780883789,
      "y": 307,
      "width": 137.6199188232422,
      "height": 25,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [
        "6WDQUhmdAueqbUmo9Jqmu"
      ],
      "frameId": null,
      "index": "aL",
      "roundness": null,
      "seed": 342840435,
      "version": 6,
      "versionNonce": 780549363,
      "isDeleted": false,
      "boundElements": [],
      "updated": 1745133279537,
      "link": null,
      "locked": false,
      "text": "Tauri 2 mobile",
      "fontSize": 20,
      "fontFamily": 5,
      "textAlign": "center",
      "verticalAlign": "middle",
      "containerId": "5DkfYx4Cj8vJKyUneZSqn",
      "originalText": "Tauri 2 mobile",
      "autoResize": true,
      "lineHeight": 1.25
    },
    {
      "id": "ysjzdJSWp3frTAn6lgmZd",
      "type": "rectangle",
      "x": 484.375,
      "y": 297.5,
      "width": 338.1953125,
      "height": 44,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [
        "6WDQUhmdAueqbUmo9Jqmu"
      ],
      "frameId": null,
      "index": "aM",
      "roundness": null,
      "seed": 1460817427,
      "version": 6,
      "versionNonce": 297697213,
      "isDeleted": false,
      "boundElements": [
        {
          "type": "text",
          "id": "E3DiiMaNoOpgs6dkloK1y"
        },
        {
          "id": "g2Je-ZuYkGeXjZhau_jRs",
          "type": "arrow"
        }
      ],
      "updated": 1745133279537,
      "link": null,
      "locked": false
    },
    {
      "id": "E3DiiMaNoOpgs6dkloK1y",
      "type": "text",
      "x": 506.09275817871094,
      "y": 307,
      "width": 294.7597961425781,
      "height": 25,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [
        "6WDQUhmdAueqbUmo9Jqmu"
      ],
      "frameId": null,
      "index": "aN",
      "roundness": null,
      "seed": 1785009075,
      "version": 5,
      "versionNonce": 686650621,
      "isDeleted": false,
      "boundElements": [],
      "updated": 1745133279536,
      "link": null,
      "locked": false,
      "text": "Apple Shortcuts / AppIntents",
      "fontSize": 20,
      "fontFamily": 5,
      "textAlign": "center",
      "verticalAlign": "middle",
      "containerId": "ysjzdJSWp3frTAn6lgmZd",
      "originalText": "Apple Shortcuts / AppIntents",
      "autoResize": true,
      "lineHeight": 1.25
    },
    {
      "id": "asQ0ZbLUw78OzauY28wbj",
      "type": "rectangle",
      "x": 872.5703125,
      "y": 297.5,
      "width": 149.8828125,
      "height": 44,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [
        "6WDQUhmdAueqbUmo9Jqmu"
      ],
      "frameId": null,
      "index": "aO",
      "roundness": null,
      "seed": 1049503059,
      "version": 6,
      "versionNonce": 1329079955,
      "isDeleted": false,
      "boundElements": [
        {
          "type": "text",
          "id": "E9teyx0efTk_1d7c1CcoB"
        },
        {
          "id": "4iIouzj--syOX6DIIgFh1",
          "type": "arrow"
        }
      ],
      "updated": 1745133279537,
      "link": null,
      "locked": false
    },
    {
      "id": "E9teyx0efTk_1d7c1CcoB",
      "type": "text",
      "x": 887.6917495727539,
      "y": 307,
      "width": 119.63993835449219,
      "height": 25,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [
        "6WDQUhmdAueqbUmo9Jqmu"
      ],
      "frameId": null,
      "index": "aP",
      "roundness": null,
      "seed": 2061763315,
      "version": 6,
      "versionNonce": 2092007453,
      "isDeleted": false,
      "boundElements": [],
      "updated": 1745133279537,
      "link": null,
      "locked": false,
      "text": "AGNO agent",
      "fontSize": 20,
      "fontFamily": 5,
      "textAlign": "center",
      "verticalAlign": "middle",
      "containerId": "asQ0ZbLUw78OzauY28wbj",
      "originalText": "AGNO agent",
      "autoResize": true,
      "lineHeight": 1.25
    },
    {
      "id": "_IlAyMorExiezo4chTlm_",
      "type": "arrow",
      "x": -68.043125,
      "y": 342,
      "width": 311.87800000000004,
      "height": 109.31899999999999,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "frameId": null,
      "index": "aQ",
      "roundness": {
        "type": 2
      },
      "seed": 401419411,
      "version": 7,
      "versionNonce": 20700211,
      "isDeleted": false,
      "boundElements": [],
      "updated": 1745133279537,
      "link": null,
      "locked": false,
      "points": [
        [
          0,
          0
        ],
        [
          -0.5,
          24.5
        ],
        [
          -0.5,
          49.5
        ],
        [
          -0.5,
          74.5
        ],
        [
          311.37800000000004,
          109.31899999999999
        ]
      ],
      "lastCommittedPoint": null,
      "startBinding": {
        "elementId": "iQN9apfNKViYkllzoh74i",
        "focus": 0.0000026981450253577357,
        "gap": 1
      },
      "endBinding": {
        "elementId": "-7Kw66fjXXrJk8OqwJASY",
        "focus": -0.000004285915471407204,
        "gap": 5.266687499999989
      },
      "startArrowhead": null,
      "endArrowhead": "arrow",
      "elbowed": false
    },
    {
      "id": "s6JQb4oR0oLBrpbYWJOmT",
      "type": "arrow",
      "x": 125.14487500000001,
      "y": 342,
      "width": 118.77100000000002,
      "height": 99.19399999999999,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "frameId": null,
      "index": "aR",
      "roundness": {
        "type": 2
      },
      "seed": 962601523,
      "version": 7,
      "versionNonce": 639988861,
      "isDeleted": false,
      "boundElements": [],
      "updated": 1745133279537,
      "link": null,
      "locked": false,
      "points": [
        [
          0,
          0
        ],
        [
          -0.5,
          24.5
        ],
        [
          -0.5,
          49.5
        ],
        [
          -0.5,
          74.5
        ],
        [
          118.27100000000002,
          99.19399999999999
        ]
      ],
      "lastCommittedPoint": null,
      "startBinding": {
        "elementId": "aBqxGZVJYiORTGhK-NqkZ",
        "focus": -0.000004030965141457859,
        "gap": 1
      },
      "endBinding": {
        "elementId": "-7Kw66fjXXrJk8OqwJASY",
        "focus": -0.00000348509715617501,
        "gap": 5.185687499999972
      },
      "startArrowhead": null,
      "endArrowhead": "arrow",
      "elbowed": false
    },
    {
      "id": "0s-3dCJ9upp4lNbKMFRrC",
      "type": "arrow",
      "x": 347.148875,
      "y": 342,
      "width": 0,
      "height": 93.69999999999999,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "frameId": null,
      "index": "aS",
      "roundness": {
        "type": 2
      },
      "seed": 1210278867,
      "version": 7,
      "versionNonce": 1350032851,
      "isDeleted": false,
      "boundElements": [],
      "updated": 1745133279537,
      "link": null,
      "locked": false,
      "points": [
        [
          0,
          0
        ],
        [
          0,
          24.5
        ],
        [
          0,
          49.5
        ],
        [
          0,
          93.69999999999999
        ]
      ],
      "lastCommittedPoint": null,
      "startBinding": {
        "elementId": "5DkfYx4Cj8vJKyUneZSqn",
        "focus": -0.000005015673981568511,
        "gap": 1
      },
      "endBinding": {
        "elementId": "-7Kw66fjXXrJk8OqwJASY",
        "focus": 0.000004462151394089906,
        "gap": 5.300000000000011
      },
      "startArrowhead": null,
      "endArrowhead": "arrow",
      "elbowed": false
    },
    {
      "id": "g2Je-ZuYkGeXjZhau_jRs",
      "type": "arrow",
      "x": 652.972875,
      "y": 342,
      "width": 202.5390000000001,
      "height": 105.15299999999999,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "frameId": null,
      "index": "aT",
      "roundness": {
        "type": 2
      },
      "seed": 1280143731,
      "version": 7,
      "versionNonce": 2044452061,
      "isDeleted": false,
      "boundElements": [],
      "updated": 1745133279537,
      "link": null,
      "locked": false,
      "points": [
        [
          0,
          0
        ],
        [
          0.5,
          24.5
        ],
        [
          0.5,
          49.5
        ],
        [
          0.5,
          74.5
        ],
        [
          -202.0390000000001,
          105.15299999999999
        ]
      ],
      "lastCommittedPoint": null,
      "startBinding": {
        "elementId": "ysjzdJSWp3frTAn6lgmZd",
        "focus": -0.0000012936311761142942,
        "gap": 1
      },
      "endBinding": {
        "elementId": "-7Kw66fjXXrJk8OqwJASY",
        "focus": 0.000012258690219187759,
        "gap": 5.238562499999944
      },
      "startArrowhead": null,
      "endArrowhead": "arrow",
      "elbowed": false
    },
    {
      "id": "4iIouzj--syOX6DIIgFh1",
      "type": "arrow",
      "x": 947.0118749999999,
      "y": 342,
      "width": 496.5329999999999,
      "height": 112.911,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "frameId": null,
      "index": "aU",
      "roundness": {
        "type": 2
      },
      "seed": 119851795,
      "version": 7,
      "versionNonce": 134392691,
      "isDeleted": false,
      "boundElements": [],
      "updated": 1745133279537,
      "link": null,
      "locked": false,
      "points": [
        [
          0,
          0
        ],
        [
          0.5,
          24.5
        ],
        [
          0.5,
          49.5
        ],
        [
          0.5,
          74.5
        ],
        [
          -496.0329999999999,
          112.911
        ]
      ],
      "lastCommittedPoint": null,
      "startBinding": {
        "elementId": "asQ0ZbLUw78OzauY28wbj",
        "focus": -0.000002084962208933625,
        "gap": 1
      },
      "endBinding": {
        "elementId": "-7Kw66fjXXrJk8OqwJASY",
        "focus": 0.000012930087259682075,
        "gap": 5.283562500000016
      },
      "startArrowhead": null,
      "endArrowhead": "arrow",
      "elbowed": false
    }
  ],
  "appState": {
    "gridSize": 20,
    "gridStep": 5,
    "gridModeEnabled": false,
    "viewBackgroundColor": "#ffffff"
  },
  "files": {}
}
</file>

<file path="RULES.md">
# RULES.md

This file provides guidance to humans and AI Agents when working with code in this repository.

## Project: lst - personal lists & notes App

### Build/Lint/Test Commands

- Build: `cargo build`
- Test all: `cargo test`
- Test single: `cargo test <test_name>`
- Run: `cargo run`
- Clippy (lint): `cargo clippy -- -D warnings`
- Format: `cargo fmt --all`

### Code Style Guidelines

- **Language**: Rust for CLI and server, TypeScript for Tauri GUI
- **Formatting**: Follow rustfmt conventions, 4 space indentation
- **Naming**: snake_case for variables/functions, CamelCase for types
- **Imports**: Group standard lib first, then external crates, then local modules
- **Error Handling**: Use Result with descriptive error types, avoid unwrap/expect
- **Types**: Prefer strong typing over generic types
- **Documentation**: Document public APIs with triple-slash comments (///)
- **Files**: Store user content in Markdown with defined frontmatter schemas
- **Architecture**: Follow client-server model with CRDT sync capabilities
</file>

<file path="crates/lst-cli/src/cli/commands.rs">
use anyhow::{bail, Context, Result};
use colored::{ColoredString, Colorize};
use serde_json;
use std::io::{self, BufRead};

use crate::cli::{DlCmd, SyncCommands};
use crate::storage;
use crate::{models::ItemStatus, storage::notes::delete_note};
use chrono::{Local, Utc};
use std::path::Path;
use std::process::{Command, Stdio};
use crate::config::{Config, get_config};

/// Handle the 'ls' command to list all lists
pub fn list_lists(json: bool) -> Result<()> {
    let lists = storage::list_lists()?;

    if json {
        println!("{}", serde_json::to_string(&lists)?);
        return Ok(());
    }

    if lists.is_empty() {
        println!("No lists found. Create one with 'lst add <list> <text>'");
        return Ok(());
    }

    println!("Available lists:");
    for list in lists {
        println!("  {}", list);
    }

    Ok(())
}
/// Handle daily list commands: create/display/add/done/undone for YYYYMMDD_daily_list
pub fn daily_list(cmd: Option<&DlCmd>, json: bool) -> Result<()> {
    let date = Local::now().format("%Y%m%d").to_string();
    let list_name = format!("{}_daily_list", date);
    // No subcommand: ensure exists then display
    match cmd {
        Some(DlCmd::Add { item }) => {
            add_item(&list_name, item, json)?;
        }
        Some(DlCmd::Done { item }) => {
            mark_done(&list_name, item, json)?;
        }
        Some(DlCmd::Undone { item }) => {
            mark_undone(&list_name, item, json)?;
        }
        None => {
            // create if missing
            if storage::markdown::load_list(&list_name).is_err() {
                storage::markdown::create_list(&list_name)?;
            }
            display_list(&list_name, json)?;
        }
    }
    Ok(())
}
/// Handle daily note: create or open YYYYMMDD_daily_note.md
pub fn daily_note(_json: bool) -> Result<()> {
    let date = Local::now().format("%Y%m%d").to_string();
    let notes_dir = storage::get_notes_dir()?;
    let filename = format!("{}_daily_note.md", date);
    let path = notes_dir.join(&filename);
    // create if missing
    if !path.exists() {
        let now = Utc::now().to_rfc3339();
        let title = filename.trim_end_matches(".md");
        let content = format!("---\ntitle: \"{}\"\ncreated: {}\n---\n\n", title, now);
        std::fs::write(&path, content)
            .context(format!("Failed to create daily note: {}", path.display()))?;
    }
    // open in editor
    open_editor(&path)
}

/// Handle the 'ls' command to list all lists
pub fn list_notes(json: bool) -> Result<()> {
    let notes = storage::list_notes()?;

    if json {
        println!("{}", serde_json::to_string(&notes)?);
        return Ok(());
    }

    if notes.is_empty() {
        println!("No notes found. Create one with 'lst note new <list>'");
        return Ok(());
    }

    println!("Available notes:");
    for note in notes {
        println!("  {}", note);
    }

    Ok(())
}

/// Create a new note: initializes file and opens in editor
pub fn note_new(title: &str) -> Result<()> {
    // Normalize title (omit .md)
    let key = title.trim_end_matches(".md");
    // Create the note file (with frontmatter)
    let path = storage::notes::create_note(key).context("Failed to create note")?;
    // Open in editor
    open_editor(&path)
}

/// Open an existing note in the editor
pub fn note_open(title: &str) -> Result<()> {
    // Resolve note (allow fuzzy and omit .md)
    let key = title.trim_end_matches(".md");
    let note = resolve_note(key)?;
    let path = storage::notes::load_note(&note).context("Failed to load note")?;
    open_editor(&path)
}
/// Append text to an existing note (or create one), then open in editor
pub fn note_add(title: &str, text: &str) -> Result<()> {
    // Resolve note key for append (omit .md)
    let key = title.trim_end_matches(".md");
    let note = resolve_note(key).unwrap_or_else(|_| key.to_string());
    // Append to note, creating if missing
    let path = storage::notes::append_to_note(&note, text).context("Failed to append to note")?;
    // Inform user of success
    println!(
        "Appended to note '{}' (file: {})",
        title.cyan(),
        path.display()
    );
    Ok(())
}

/// Delete a note
pub fn note_delete(title: &str) -> Result<()> {
    // Determine the note file path
    // Resolve note to delete
    let key = title.trim_end_matches(".md");
    let note = resolve_note(key)?;
    delete_note(&note)
}

/// Spawn the user's editor (from $EDITOR or default 'vi') on the given path
fn open_editor(path: &Path) -> Result<()> {
    let editor = std::env::var("EDITOR").unwrap_or_else(|_| "vi".to_string());
    let status = Command::new(editor)
        .arg(path)
        .status()
        .context("Failed to launch editor")?;
    if !status.success() {
        anyhow::bail!("Editor exited with non-zero status");
    }
    Ok(())
}
/// Normalize a list identifier: strip .md and fuzzy-match existing, or allow new
fn normalize_list(input: &str) -> Result<String> {
    let key = input.trim_end_matches(".md");
    let lists = storage::list_lists()?;
    if lists.contains(&key.to_string()) {
        return Ok(key.to_string());
    }
    let matches: Vec<&String> = lists.iter().filter(|l| l.contains(key)).collect();
    if matches.len() == 1 {
        return Ok(matches[0].clone());
    }
    Ok(key.to_string())
}
/// Normalize a note identifier: strip .md and fuzzy-match existing, or allow new
fn normalize_note(input: &str) -> Result<String> {
    let key = input.trim_end_matches(".md");
    let notes = storage::list_notes()?;
    if notes.contains(&key.to_string()) {
        return Ok(key.to_string());
    }
    let matches: Vec<&String> = notes.iter().filter(|n| n.contains(key)).collect();
    if !matches.is_empty() {
        // Fuzzy match: take first matching note
        return Ok(matches[0].clone());
    }
    bail!("No note matching '{}' found", key)
}
/// Resolve a note identifier: strip .md and fuzzy-match to exactly one or error
fn resolve_note(input: &str) -> Result<String> {
    let key = input.trim_end_matches(".md");
    let notes = storage::list_notes()?;
    if notes.contains(&key.to_string()) {
        return Ok(key.to_string());
    }
    let matches: Vec<&String> = notes.iter().filter(|n| n.contains(key)).collect();
    match matches.len() {
        1 => Ok(matches[0].clone()),
        0 => bail!("No note matching '{}' found", input),
        _ => bail!("Multiple notes match '{}': {:?}", input, matches),
    }
}

/// Handle the 'add' command to add an item to a list
pub fn add_item(list: &str, text: &str, json: bool) -> Result<()> {
    // Try to load the list, create it if it doesn't exist
    // Resolve list name (omit .md, fuzzy match)
    let list_name = normalize_list(list)?;
    let list_result = storage::markdown::load_list(&list_name);
    if list_result.is_err() {
        storage::markdown::create_list(&list_name)?;
    }

    // Split by commas and trim whitespace
    let items: Vec<&str> = text.split(',').map(|s| s.trim()).collect();
    let mut added_items = Vec::new();

    for item_text in items {
        if !item_text.is_empty() {
            let item = storage::markdown::add_item(&list_name, item_text)?;
            added_items.push(item);
        }
    }

    if json {
        println!("{}", serde_json::to_string(&added_items)?);
        return Ok(());
    }

    if added_items.len() == 1 {
        println!("Added to {}: {}", list_name.cyan(), added_items[0].text);
    } else {
        println!("Added {} items to {}:", added_items.len(), list.cyan());
        for item in added_items {
            println!("  {}", item.text);
        }
    }

    Ok(())
}

/// Handle the 'done' command to mark an item as done
pub fn mark_done(list: &str, target: &str, json: bool) -> Result<()> {
    let list_name = normalize_list(list)?;
    let items = storage::markdown::mark_done(&list_name, target)?;

    if json {
        println!("{}", serde_json::to_string(&items)?);
        return Ok(());
    }

    if items.len() == 1 {
        println!("Marked done in {}: {}", list_name.cyan(), items[0].text);
    } else {
        println!("Marked {} items as done in {}:", items.len(), list_name.cyan());
        for item in &items {
            println!("  {}", item.text);
        }
    }

    Ok(())
}

/// Handle the 'undone' command to mark a completed item as not done
pub fn mark_undone(list: &str, target: &str, json: bool) -> Result<()> {
    let list_name = normalize_list(list)?;
    let items = storage::markdown::mark_undone(&list_name, target)?;

    if json {
        println!("{}", serde_json::to_string(&items)?);
        return Ok(());
    }

    if items.len() == 1 {
        println!("Marked undone in {}: {}", list_name.cyan(), items[0].text);
    } else {
        println!("Marked {} items as undone in {}:", items.len(), list_name.cyan());
        for item in &items {
            println!("  {}", item.text);
        }
    }

    Ok(())
}
/// Handle the 'rm' command to remove an item from a list
pub fn remove_item(list: &str, target: &str, json: bool) -> Result<()> {
    let list_name = normalize_list(list)?;
    
    // Use the storage layer implementation
    let removed = storage::markdown::delete_item(&list_name, target)
        .with_context(|| format!("Failed to delete '{}' from {}", target, list_name))?;

    if json {
        println!("{}", serde_json::to_string(&removed)?);
        return Ok(());
    }
    
    if removed.len() == 1 {
        println!("Deleted from {}: {}", list_name.cyan(), removed[0].text);
    } else {
        println!("Deleted {} items from {}:", removed.len(), list_name.cyan());
        for item in &removed {
            println!("  {}", item.text);
        }
    }
    Ok(())
}

/// Handle the 'pipe' command to read items from stdin
pub fn pipe(list: &str, json: bool) -> Result<()> {
    // Try to load the list, create it if it doesn't exist
    let list_name = normalize_list(list)?;
    let list_result = storage::markdown::load_list(&list_name);
    if list_result.is_err() {
        storage::markdown::create_list(list)?;
    }

    let stdin = io::stdin();
    let mut count = 0;

    for line in stdin.lock().lines() {
        let line = line?;
        if !line.trim().is_empty() {
            storage::markdown::add_item(&list_name, &line)?;
            count += 1;
        }
    }

    if json {
        println!("{{\"added\": {}}}", count);
        return Ok(());
    }

    println!("Added {} items to {}", count, list_name.cyan());

    Ok(())
}

/// Handle displaying a list
pub fn display_list(list: &str, json: bool) -> Result<()> {
    let list_name = normalize_list(list)?;
    let list = storage::markdown::load_list(&list_name)?;

    if json {
        println!("{}", serde_json::to_string(&list)?);
        return Ok(());
    }

    println!("{}:", list.metadata.title.cyan().bold());

    if list.items.is_empty() {
        println!("  No items in list");
        return Ok(());
    }

    for (idx, item) in list.items.iter().enumerate() {
        let checkbox: ColoredString = match item.status {
            ItemStatus::Todo => "[ ]".into(),
            ItemStatus::Done => "[x]".green(),
        };
        
        let text = match item.status {
            ItemStatus::Todo => item.text.normal(),
            ItemStatus::Done => item.text.strikethrough(),
        };

        println!(
            "#{} {} {} {}",
            idx + 1,
            checkbox,
            text,
            item.anchor.dimmed()
        );
    }

    Ok(())
}

/// Handle sync daemon commands
pub fn handle_sync_command(cmd: SyncCommands, json: bool) -> Result<()> {
    match cmd {
        SyncCommands::Setup { server, token } => sync_setup(server, token, json),
        SyncCommands::Start { foreground } => sync_start(foreground, json),
        SyncCommands::Stop => sync_stop(json),
        SyncCommands::Status => sync_status(json),
        SyncCommands::Logs { follow, lines } => sync_logs(follow, lines, json),
    }
}

/// Setup sync configuration (first login flow)
pub fn sync_setup(server: Option<String>, token: Option<String>, json: bool) -> Result<()> {
    use dialoguer::{Input, Confirm};
    
    let mut config = Config::load()?;
    config.init_syncd()?;
    
    let server_url = if let Some(url) = server {
        url
    } else {
        Input::<String>::new()
            .with_prompt("Enter server URL (leave empty for local-only mode)")
            .allow_empty(true)
            .interact()?
    };
    
    let auth_token = if server_url.is_empty() {
        None
    } else if let Some(token) = token {
        Some(token)
    } else {
        let token: String = Input::new()
            .with_prompt("Enter authentication token")
            .interact()?;
        if token.is_empty() { None } else { Some(token) }
    };
    
    if let Some(ref mut syncd) = config.syncd {
        syncd.url = if server_url.is_empty() { None } else { Some(server_url.clone()) };
        syncd.auth_token = auth_token.clone();
    }
    
    config.save()?;
    
    if json {
        println!("{{\"status\": \"configured\", \"server\": {:?}, \"has_token\": {}}}", 
            server_url, auth_token.is_some());
    } else {
        if server_url.is_empty() {
            println!("Configured for local-only mode");
        } else {
            println!("Configured to sync with: {}", server_url.cyan());
            if auth_token.is_some() {
                println!("Authentication token set");
            }
        }
        
        if Confirm::new()
            .with_prompt("Start sync daemon now?")
            .default(true)
            .interact()? 
        {
            sync_start(false, json)?;
        }
    }
    
    Ok(())
}

/// Start sync daemon
pub fn sync_start(foreground: bool, json: bool) -> Result<()> {
    // Check if syncd binary exists
    let syncd_path = find_syncd_binary()?;
    
    let mut cmd = Command::new(&syncd_path);
    if foreground {
        cmd.arg("--foreground");
    }
    cmd.arg("--verbose");
    
    if foreground {
        // Run in foreground
        let status = cmd.status()?;
        if !status.success() {
            bail!("lst-syncd exited with status: {}", status);
        }
    } else {
        // Start daemon in background
        cmd.stdout(Stdio::null())
           .stderr(Stdio::null())
           .stdin(Stdio::null());
        
        let child = cmd.spawn()?;
        let pid = child.id();
        
        if json {
            println!("{{\"status\": \"started\", \"pid\": {}}}", pid);
        } else {
            println!("Sync daemon started (PID: {})", pid);
        }
    }
    
    Ok(())
}

/// Stop sync daemon
pub fn sync_stop(json: bool) -> Result<()> {
    // Find running lst-syncd process and stop it
    let output = Command::new("pkill")
        .args(&["-f", "lst-syncd"])
        .output()?;
    
    if json {
        println!("{{\"status\": \"stopped\"}}");
    } else {
        if output.status.success() {
            println!("Sync daemon stopped");
        } else {
            println!("No sync daemon found running");
        }
    }
    
    Ok(())
}

/// Show sync daemon status
pub fn sync_status(json: bool) -> Result<()> {
    let config = get_config();
    
    // Check if syncd is configured
    let configured = config.syncd.is_some();
    let server_url = config.syncd.as_ref().and_then(|s| s.url.as_ref());
    let has_token = config.syncd.as_ref().and_then(|s| s.auth_token.as_ref()).is_some();
    
    // Check if daemon is running
    let running = Command::new("pgrep")
        .args(&["-f", "lst-syncd"])
        .output()
        .map(|output| output.status.success())
        .unwrap_or(false);
    
    if json {
        println!("{{\"configured\": {}, \"running\": {}, \"server\": {:?}, \"has_token\": {}}}", 
            configured, running, server_url, has_token);
    } else {
        println!("Sync Configuration:");
        println!("  Configured: {}", if configured { "Yes".green() } else { "No".red() });
        
        if let Some(url) = server_url {
            println!("  Server: {}", url.cyan());
        } else {
            println!("  Mode: {}", "Local-only".yellow());
        }
        
        println!("  Auth token: {}", if has_token { "Set".green() } else { "Not set".red() });
        println!("  Daemon: {}", if running { "Running".green() } else { "Stopped".red() });
        
        if !configured {
            println!("\nRun 'lst sync setup' to configure sync settings");
        } else if !running {
            println!("\nRun 'lst sync start' to start the sync daemon");
        }
    }
    
    Ok(())
}

/// Show sync daemon logs
pub fn sync_logs(follow: bool, lines: usize, _json: bool) -> Result<()> {
    println!("Sync daemon logs (last {} lines):", lines);
    
    // For now, just indicate that logging isn't implemented yet
    println!("Log viewing not implemented yet - check system logs for lst-syncd");
    
    if follow {
        println!("Use 'lst sync start --foreground' to see live output");
    }
    
    Ok(())
}

/// Find the lst-syncd binary
fn find_syncd_binary() -> Result<String> {
    // Try common locations for lst-syncd
    let possible_paths = [
        "lst-syncd", // In PATH
        "./target/debug/lst-syncd", // Local debug build
        "./target/release/lst-syncd", // Local release build
        &std::env::current_exe()
            .ok()
            .and_then(|p| p.parent().map(|parent| parent.join("lst-syncd")))
            .and_then(|p| p.to_str().map(String::from))
            .unwrap_or_default(),
    ];
    
    for path in possible_paths.iter() {
        if path.is_empty() { continue; }
        
        if Command::new(path).arg("--help").output().is_ok() {
            return Ok(path.to_string());
        }
    }
    
    bail!("lst-syncd binary not found. Make sure it's installed and in your PATH.");
}
</file>

<file path="crates/lst-cli/src/cli/mod.rs">
pub mod commands;

use clap::{Parser, Subcommand};

#[derive(Parser)]
#[clap(name = "lst", about = "Personal lists & notes app")]
#[clap(version, author)]
pub struct Cli {
    #[clap(subcommand)]
    pub command: Commands,

    /// Output in JSON format
    #[clap(long, global = true)]
    pub json: bool,
}

#[derive(Subcommand)]
pub enum Commands {
    /// List all lists or show contents of a specific list
    #[clap(name = "ls")]
    ListLists {
        /// Name of the list to show (optional)
        list: Option<String>,
    },

    /// Add an item to a list
    #[clap(name = "add")]
    Add {
        /// Name of the list
        list: String,
        /// Text of the item(s) to add (comma-separated for multiple items)
        text: String,
    },

    /// Mark an item as done
    #[clap(name = "done")]
    Done {
        /// Name of the list
        list: String,
        /// Target item to mark as done (anchor, text, or index; comma-separated for multiple items)
        target: String,
    },
    
    /// Mark a completed item as not done
    #[clap(name = "undone")]
    Undone {
        /// Name of the list
        list: String,
        /// Target item to mark as not done (anchor, text, or index; comma-separated for multiple items)
        target: String,
    },

    /// Delete item from a list
    #[clap(name = "rm")]
    Rm {
        /// Name of the list
        list: String,
        /// Target item to delete (anchor, text, or index; comma-separated for multiple items)
        target: String,
    },

    /// Read items from stdin and add them to a list
    #[clap(name = "pipe")]
    Pipe {
        /// Name of the list
        list: String,
    },

    /// Commands for managing notes
    #[clap(subcommand, name = "note")]
    Note(NoteCommands),

    /// Commands for managing images
    #[clap(subcommand, name = "img")]
    Image(ImageCommands),

    /// Daily list commands (add, done, or display)
    #[clap(name = "dl")]
    Dl {
        #[clap(subcommand)]
        cmd: Option<DlCmd>,
    },

    /// Daily note: create or open today's note
    #[clap(name = "dn")]
    Dn,

    /// Sync daemon commands
    #[clap(subcommand, name = "sync")]
    Sync(SyncCommands),
}

#[derive(Subcommand)]
pub enum NoteCommands {
    /// Create a new note
    #[clap(name = "new")]
    New {
        /// Title of the note
        title: String,
    },

    /// Append text to a note (create if it doesn't exist)
    #[clap(name = "add")]
    Add {
        /// Title of the note
        title: String,
        /// Text to append to the note
        text: String,
    },

    /// Open a note in the default editor
    #[clap(name = "open")]
    Open {
        /// Title of the note
        title: String,
    },

    /// Delete a note
    #[clap(name = "rm")]
    Remove {
        /// Name of the list
        title: String,
    },

    /// List all notes
    #[clap(name = "ls")]
    ListNotes {},
}

#[derive(Subcommand)]
pub enum ImageCommands {
    /// Add an image to a document
    #[clap(name = "add")]
    Add {
        /// Path to the image file
        file: String,
        /// Document to add the image to
        #[clap(long)]
        to: String,
        /// Caption for the image
        #[clap(long)]
        caption: Option<String>,
    },

    /// Paste image from clipboard
    #[clap(name = "paste")]
    Paste {
        /// Document to add the image to
        #[clap(long)]
        to: Option<String>,
        /// Caption for the image
        #[clap(long)]
        caption: Option<String>,
        /// Output for clipboard
        #[clap(long)]
        clipboard: bool,
    },

    /// List images in a document
    #[clap(name = "list")]
    List {
        /// Document to list images from
        document: String,
    },

    /// Remove an image reference from a document
    #[clap(name = "rm")]
    Remove {
        /// Document containing the image
        document: String,
        /// Hash of the image to remove
        hash: String,
    },
}

/// Subcommands for daily list
#[derive(Subcommand)]
pub enum DlCmd {
    /// Add item to today's daily list
    #[clap(name = "add")]
    Add {
        /// Text of the item to add
        item: String,
    },

    /// Mark an item as done in today's daily list
    #[clap(name = "done")]
    Done {
        /// Target item to mark as done (anchor, text, or index; comma-separated for multiple items)
        item: String,
    },
    
    /// Mark an item as not done in today's daily list
    #[clap(name = "undone")]
    Undone {
        /// Target item to mark as not done (anchor, text, or index; comma-separated for multiple items)
        item: String,
    },
}

/// Subcommands for sync daemon management
#[derive(Clone, Subcommand)]
pub enum SyncCommands {
    /// Start sync daemon in background
    #[clap(name = "start")]
    Start {
        /// Run in foreground mode (don't daemonize)
        #[clap(long)]
        foreground: bool,
    },

    /// Stop sync daemon
    #[clap(name = "stop")]
    Stop,

    /// Show sync daemon status
    #[clap(name = "status")]
    Status,

    /// Configure sync settings
    #[clap(name = "setup")]
    Setup {
        /// Server URL to sync with
        #[clap(long)]
        server: Option<String>,
        /// Authentication token
        #[clap(long)]
        token: Option<String>,
    },

    /// Show sync daemon logs
    #[clap(name = "logs")]
    Logs {
        /// Follow logs in real-time
        #[clap(short, long)]
        follow: bool,
        /// Number of lines to show
        #[clap(short, long, default_value = "50")]
        lines: usize,
    },
}
</file>

<file path="crates/lst-cli/src/main.rs">
mod cli;
mod config;
mod models;
mod storage;

use anyhow::Result;
use clap::Parser;
use cli::{Cli, Commands, ImageCommands, NoteCommands};

fn main() -> Result<()> {
    // Parse command line arguments
    let cli = Cli::parse();

    // Configuration is now loaded on first use via a global cache

    // Process commands
    match &cli.command {
        Commands::ListLists { list } => {
            if let Some(list_name) = list {
                cli::commands::display_list(list_name, cli.json)?;
            } else {
                cli::commands::list_lists(cli.json)?;
            }
        }
        Commands::Add { list, text } => {
            cli::commands::add_item(list, text, cli.json)?;
        }
        Commands::Done { list, target } => {
            cli::commands::mark_done(list, target, cli.json)?;
        }
        Commands::Undone { list, target } => {
            cli::commands::mark_undone(list, target, cli.json)?;
        }
        Commands::Rm { list, target } => {
            cli::commands::remove_item(list, target, cli.json)?;
        }
        Commands::Pipe { list } => {
            cli::commands::pipe(list, cli.json)?;
        }
        Commands::Note(note_cmd) => match note_cmd {
            NoteCommands::New { title } => cli::commands::note_new(title)?,
            NoteCommands::Add { title, text } => {
                cli::commands::note_add(title, text)?;
            }
            NoteCommands::Open { title } => cli::commands::note_open(title)?,
            NoteCommands::Remove { title } => cli::commands::note_delete(title)?,
            NoteCommands::ListNotes {} => {
                cli::commands::list_notes(cli.json)?;
            }
        },
        // Commands::Post(post_cmd) => {
        //     match post_cmd {
        //         PostCommands::New { title: _ } => {
        //             eprintln!("Post commands not implemented yet");
        //         },
        //         PostCommands::List => {
        //             eprintln!("Post commands not implemented yet");
        //         },
        //         PostCommands::Publish { slug: _ } => {
        //             eprintln!("Post commands not implemented yet");
        //         },
        //     }
        // },
        Commands::Dl { cmd } => {
            cli::commands::daily_list(cmd.as_ref(), cli.json)?;
        }
        Commands::Dn => {
            cli::commands::daily_note(cli.json)?;
        }
        Commands::Sync(sync_cmd) => {
            cli::commands::handle_sync_command(sync_cmd.clone(), cli.json)?;
        }
        Commands::Image(img_cmd) => match img_cmd {
            ImageCommands::Add {
                file: _,
                to: _,
                caption: _,
            } => {
                eprintln!("Image commands not implemented yet");
            }
            ImageCommands::Paste {
                to: _,
                caption: _,
                clipboard: _,
            } => {
                eprintln!("Image commands not implemented yet");
            }
            ImageCommands::List { document: _ } => {
                eprintln!("Image commands not implemented yet");
            }
            ImageCommands::Remove {
                document: _,
                hash: _,
            } => {
                eprintln!("Image commands not implemented yet");
            }
        },
    }

    Ok(())
}
</file>

<file path="crates/lst-cli/Cargo.toml">
[package]
name = "lst-cli"
version = "0.1.0"
description = "Personal lists & notes app CLI"
authors = ["Tommy Falkowski"]
edition = "2021"

[lib]
name = "lst_cli"
path = "src/lib.rs"

[[bin]]
name = "lst"
path = "src/main.rs"

[dependencies]
# CLI
clap = { workspace = true }
colored = { workspace = true }
dialoguer = { workspace = true }
console = { workspace = true }

# Storage & sync
serde = { workspace = true }
serde_yaml = { workspace = true }
serde_json = { workspace = true }
toml = { workspace = true }
dirs = { workspace = true }
uuid = { workspace = true }

# Error handling
anyhow = { workspace = true }
thiserror = { workspace = true }

# Utilities
chrono = { workspace = true }
regex = { workspace = true }
lazy_static = { workspace = true }
rand = { workspace = true }

[features]
default = ["lists"]
lists = []
notes = []
posts = []
media = []
</file>

<file path="crates/lst-server/src/config.rs">
use serde::Deserialize;
use anyhow::Context;
use std::{env, fs, path::Path};

/// Server configuration loaded from TOML file
#[derive(Debug, Deserialize, Clone)]
pub struct Settings {
    #[serde(default)]
    pub lst_server: ServerSettings,
    /// SMTP/email settings; if absent, login links are logged to stdout
    pub email: Option<EmailSettings>,
    #[serde(default)]
    pub paths: PathsSettings,
}

/// Network settings for the HTTP server
#[derive(Debug, Deserialize, Clone)]
pub struct ServerSettings {
    /// Host/interface to bind to, e.g. "127.0.0.1"
    #[serde(default = "default_host")]
    pub host: String,
    /// Port to listen on, e.g. 3000
    #[serde(default = "default_port")]
    pub port: u16,
}

fn default_host() -> String {
    "127.0.0.1".to_string()
}

fn default_port() -> u16 {
    3000
}

/// SMTP relay settings for sending login emails
#[derive(Debug, Deserialize, Clone)]
pub struct EmailSettings {
    pub smtp_host: String,
    pub smtp_user: String,
    pub smtp_pass: String,
    pub sender: String,
}

/// Path settings shared with CLI
#[derive(Debug, Deserialize, Clone)]
pub struct PathsSettings {
    /// Root path for content files
    pub content_dir: Option<String>,
    /// Document kinds (e.g. ["lists", "notes", "posts"])
    pub kinds: Option<Vec<String>>,
    /// Subdirectory for media files under content root
    pub media_dir: Option<String>,
}

impl Default for ServerSettings {
    fn default() -> Self {
        Self {
            host: default_host(),
            port: default_port(),
        }
    }
}

impl Default for PathsSettings {
    fn default() -> Self {
        Self {
            content_dir: None,
            kinds: None,
            media_dir: None,
        }
    }
}

impl Settings {
    /// Load and parse the configuration from the given TOML file path
    pub fn from_file(path: &Path) -> anyhow::Result<Self> {
        let data = fs::read_to_string(path)
            .with_context(|| format!("failed to read config file {}", path.display()))?;
        let mut settings: Settings = toml::from_str(&data)
            .with_context(|| format!("failed to parse config file {}", path.display()))?;
        // Expand SMTP password from environment variable if in ${VAR} form
        if let Some(ref mut email) = settings.email {
            if email.smtp_pass.starts_with("${") && email.smtp_pass.ends_with('}') {
                let var = &email.smtp_pass[2..email.smtp_pass.len() - 1];
                email.smtp_pass = env::var(var)
                    .with_context(|| format!("missing environment var {} for smtp_pass", var))?;
            }
        }
        Ok(settings)
    }

    /// Load configuration from the standard lst config location
    pub fn load() -> anyhow::Result<Self> {
        let home_dir = dirs::home_dir().context("Could not determine home directory")?;
        let config_path = home_dir.join(".config").join("lst").join("lst.toml");
        Self::from_file(&config_path)
    }
}
</file>

<file path="crates/lst-server/src/main.rs">
mod config;
mod wordlist;

use axum::http::StatusCode;
use axum::{
    routing::{get, post},
    Json, Router,
};
use base64::{engine::general_purpose, Engine as _};
use clap::Parser;
use config::Settings;
use image::Luma;
use jsonwebtoken::{encode, EncodingKey, Header};
use lettre::transport::smtp::authentication::Credentials;
use lettre::{message::Message, AsyncSmtpTransport, AsyncTransport, Tokio1Executor};
use qrcode::QrCode;
use rand::seq::SliceRandom;
use rand::Rng;
use serde::{Deserialize, Serialize};
use std::{
    collections::HashMap,
    net::{IpAddr, SocketAddr},
    sync::{Arc, Mutex},
};

// Global in-memory token store (email -> (token, expiry))
type TokenMap = Arc<Mutex<HashMap<String, (String, std::time::Instant)>>>;
const TOKEN_VALID_FOR: u64 = 15 * 60; // 15 min in seconds

#[derive(Deserialize)]
struct AuthRequest {
    email: String,
    host: String, // must be provided by the client for correct QR
}

#[derive(Serialize)]
struct AuthToken {
    token: String,
    qr_png_base64: String,
    login_url: String,
}

#[derive(Parser)]
#[command(name = "lst-server", about = "lst server API")]
struct Args {
    /// Path to server configuration TOML file
    #[arg(long, default_value = "~/.config/lst/lst.toml")]
    config: String,
}

#[tokio::main]
async fn main() {
    let args = Args::parse();
    let config_path = if args.config.starts_with("~/") {
        dirs::home_dir().unwrap().join(&args.config[2..])
    } else {
        std::path::PathBuf::from(args.config)
    };
    let settings = Arc::new(Settings::from_file(&config_path).unwrap());

    let token_map: TokenMap = Arc::new(Mutex::new(HashMap::new()));
    let app = Router::new().nest(
        "/api",
        Router::new()
            .route("/health", get(health_handler))
            .route(
                "/auth/request",
                post({
                    let token_map = token_map.clone();
                    let settings = settings.clone();
                    move |j| auth_request_handler(j, token_map.clone(), settings.clone())
                }),
            )
            .route(
                "/auth/verify",
                post({
                    let token_map = token_map.clone();
                    move |j| auth_verify_handler(j, token_map.clone())
                }),
            ),
    );
    let addr = SocketAddr::new(
        settings.lst_server.host.parse::<IpAddr>().unwrap(),
        settings.lst_server.port,
    );
    println!("lst-server listening on http://{}", addr);
    let listener = tokio::net::TcpListener::bind(addr).await.unwrap();
    axum::serve(listener, app.into_make_service())
        .await
        .unwrap();
}

async fn health_handler() -> &'static str {
    "OK"
}

async fn auth_request_handler(
    Json(req): Json<AuthRequest>,
    tokens: TokenMap,
    settings: Arc<Settings>,
) -> Result<Json<AuthToken>, (StatusCode, String)> {
    let token = generate_token();
    let expiry = std::time::Instant::now() + std::time::Duration::from_secs(TOKEN_VALID_FOR);
    {
        let mut map = tokens.lock().unwrap();
        map.insert(req.email.clone(), (token.clone(), expiry));
    }
    let login_url = format!(
        "lst-login://{}/auth/verify?token={}&email={}",
        req.host,
        urlencoding::encode(&token),
        urlencoding::encode(&req.email)
    );
    let code = QrCode::new(login_url.as_bytes()).unwrap();
    let img = code.render::<Luma<u8>>().max_dimensions(300, 300).build();
    let mut buf = std::io::Cursor::new(Vec::new());
    {
        use image::codecs::png::PngEncoder;
        use image::ColorType;
        use image::ImageEncoder;

        let encoder = PngEncoder::new(&mut buf);
        encoder
            .write_image(
                img.as_raw(),
                img.width(),
                img.height(),
                ColorType::L8.into(),
            )
            .unwrap();
    }
    let base64_png = general_purpose::STANDARD.encode(buf.get_ref());

    if let Some(email_cfg) = &settings.email {
        let email = Message::builder()
            .from(email_cfg.sender.parse().map_err(|e| {
                (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    format!("invalid sender address: {}", e),
                )
            })?)
            .to(req.email.parse().map_err(|e| {
                (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    format!("invalid recipient address: {}", e),
                )
            })?)
            .subject("Your lst login link")
            .body(format!(
                "Click to login: {}\nOr use code: {}",
                login_url, token
            ))
            .map_err(|e| {
                (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    format!("failed to build email: {}", e),
                )
            })?;
        let creds = Credentials::new(email_cfg.smtp_user.clone(), email_cfg.smtp_pass.clone());
        let mailer = AsyncSmtpTransport::<Tokio1Executor>::relay(&email_cfg.smtp_host)
            .map_err(|e| {
                (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    format!("failed to create SMTP transport: {}", e),
                )
            })?
            .credentials(creds)
            .build();
        mailer.send(email).await.map_err(|e| {
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                format!("failed to send email: {}", e),
            )
        })?;
    } else {
        println!("Login link for {}: {}", req.email, login_url);
    }

    Ok(Json(AuthToken {
        token,
        qr_png_base64: base64_png,
        login_url,
    }))
}

fn generate_token() -> String {
    let mut rng = rand::thread_rng();
    let words = wordlist::WORDS;
    let picks: Vec<&str> = words.choose_multiple(&mut rng, 3).cloned().collect();
    let digits: u16 = rng.gen_range(1000..10000);
    format!(
        "{}-{}-{}-{}",
        picks[0].to_uppercase(),
        picks[1].to_uppercase(),
        picks[2].to_uppercase(),
        digits
    )
}

#[derive(Deserialize)]
struct VerifyRequest {
    email: String,
    token: String,
}

#[derive(Serialize)]
struct VerifyResponse {
    jwt: String,
    user: String,
}

#[derive(Serialize, Deserialize)]
struct Claims {
    sub: String,
    exp: usize,
}

async fn auth_verify_handler(
    Json(req): Json<VerifyRequest>,
    tokens: TokenMap,
) -> Result<Json<VerifyResponse>, (StatusCode, String)> {
    let now = std::time::Instant::now();
    let mut map = tokens.lock().unwrap();
    // Check token matches for email
    match map.remove(&req.email) {
        Some((t, expiry)) if t == req.token && expiry >= now => {
            // Generate JWT
            let jwt_secret = b"lst-jwt-demo-secret-goes-here";
            let exp = (chrono::Utc::now() + chrono::Duration::hours(1)).timestamp() as usize;
            let claims = Claims {
                sub: req.email.clone(),
                exp,
            };
            let jwt = encode(
                &Header::default(),
                &claims,
                &EncodingKey::from_secret(jwt_secret),
            )
            .unwrap();
            Ok(Json(VerifyResponse {
                jwt,
                user: req.email,
            }))
        }
        _ => Err((StatusCode::UNAUTHORIZED, "Invalid or expired token".into())),
    }
}
</file>

<file path="crates/lst-syncd/src/config.rs">
pub use lst_cli::config::Config;
use anyhow::{Context, Result};
use std::{fs, path::Path};

/// Load syncd configuration from the unified lst config
pub fn load_syncd_config(path: &Path) -> Result<Config> {
    let config = if !path.exists() {
        // Create default config with syncd enabled
        let mut default_config = Config::default();
        default_config.init_syncd()?;
        
        // Ensure config directory exists
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent)
                .with_context(|| format!("Failed to create config directory: {}", parent.display()))?;
        }
        
        // Write default config
        default_config.save()
            .context("Failed to save default config with syncd settings")?;
        
        println!("Created default config with sync daemon settings at: {}", path.display());
        default_config
    } else {
        let mut config = Config::load_from(path)?;
        
        // Initialize syncd if not present
        if config.syncd.is_none() {
            config.init_syncd()?;
            config.save()
                .context("Failed to save config with syncd settings")?;
            println!("Added sync daemon settings to existing config");
        }
        
        // Generate device_id if missing
        if let Some(syncd) = &config.syncd {
            if syncd.device_id.is_none() {
                let mut updated_config = config.clone();
                if let Some(ref mut syncd) = updated_config.syncd {
                    let device_id = uuid::Uuid::new_v4().to_string();
                    syncd.device_id = Some(device_id.clone());
                    updated_config.save()
                        .context("Failed to save config with new device_id")?;
                    println!("Generated new device_id: {}", device_id);
                    return Ok(updated_config);
                }
            }
        }
        
        config
    };
    
    Ok(config)
}
</file>

<file path="crates/lst-syncd/src/main.rs">
mod config;
mod sync;
mod watcher;

use anyhow::Result;
use clap::Parser;
use std::path::PathBuf;

use crate::config::{load_syncd_config};
use crate::sync::SyncManager;
use crate::watcher::FileWatcher;

#[derive(Parser)]
#[command(name = "lst-syncd", about = "Background sync daemon for lst")]
struct Args {
    /// Path to sync daemon configuration file
    #[arg(long, default_value = "~/.config/lst/lst.toml")]
    config: String,

    /// Run in foreground mode (don't daemonize)
    #[arg(long)]
    foreground: bool,

    /// Verbose logging
    #[arg(short, long)]
    verbose: bool,
}

#[tokio::main]
async fn main() -> Result<()> {
    let args = Args::parse();

    // Expand config path
    let config_path = if args.config.starts_with("~/") {
        dirs::home_dir().unwrap().join(&args.config[2..])
    } else {
        PathBuf::from(args.config)
    };

    // Load configuration
    let config = load_syncd_config(&config_path)?;

    if args.verbose {
        println!("lst-syncd starting with config: {}", config_path.display());
        println!(
            "Watching content directory: {}",
            config.get_content_dir().display()
        );
        if let Some(ref syncd) = config.syncd {
            if let Some(ref server_url) = syncd.url {
                println!("Syncing to server: {}", server_url);
            } else {
                println!("No server configured - running in local-only mode");
            }
        } else {
            println!("No sync daemon configuration found - running in local-only mode");
        }
    }

    // Initialize file watcher
    let content_dir = config.get_content_dir();
    let mut watcher = FileWatcher::new(&content_dir)?;

    // Initialize sync manager
    let mut sync_manager = SyncManager::new(config.clone()).await?;

    if !args.foreground {
        println!("lst-syncd daemon started");
        // TODO: Daemonize process (platform-specific)
    }

    // Main event loop
    loop {
        tokio::select! {
            // Handle file system events
            event = watcher.next_event() => {
                if let Some(event) = event {
                    if args.verbose {
                        println!("File event: {:?}", event);
                    }
                    sync_manager.handle_file_event(event).await?;
                }
            }

            // Periodic sync check (every 30 seconds)
            _ = tokio::time::sleep(tokio::time::Duration::from_secs(30)) => {
                if args.verbose {
                    println!("Performing periodic sync check");
                }
                sync_manager.periodic_sync().await?;
            }

            // Handle shutdown signals
            _ = tokio::signal::ctrl_c() => {
                println!("Received shutdown signal, stopping lst-syncd");
                break;
            }
        }
    }

    Ok(())
}
</file>

<file path="crates/lst-syncd/src/sync.rs">
use anyhow::{Context, Result};
use notify::Event;
use std::collections::HashMap;
use tokio::time::Instant;

use crate::config::Config;
use lst_proto::SyncMessage;

pub struct SyncManager {
    config: Config,
    client: Option<reqwest::Client>,
    last_sync: Instant,
    pending_changes: HashMap<String, SyncMessage>,
}

impl SyncManager {
    pub async fn new(config: Config) -> Result<Self> {
        let client = if config.syncd.as_ref().and_then(|s| s.url.as_ref()).is_some() {
            Some(reqwest::Client::new())
        } else {
            None
        };
        
        // Ensure CRDT storage directory exists
        if let Some(ref storage) = config.storage {
            tokio::fs::create_dir_all(&storage.crdt_dir)
                .await
                .with_context(|| format!("Failed to create CRDT directory: {}", storage.crdt_dir.display()))?;
        }
        
        Ok(Self {
            config,
            client,
            last_sync: Instant::now(),
            pending_changes: HashMap::new(),
        })
    }
    
    pub async fn handle_file_event(&mut self, event: Event) -> Result<()> {
        // TODO: Process file changes into CRDT operations
        // TODO: Store changes locally
        // TODO: Queue for remote sync if server is configured
        
        for path in event.paths {
            if let Some(filename) = path.file_name() {
                if let Some(filename_str) = filename.to_str() {
                    // Skip temporary files and hidden files
                    if filename_str.starts_with('.') || 
                       filename_str.ends_with(".tmp") || 
                       filename_str.ends_with(".swp") {
                        continue;
                    }
                }
            }
            
            println!("Processing file change: {}", path.display());
            
            // TODO: Convert file changes to CRDT operations
            // TODO: Encrypt CRDT data
            // TODO: Store in local CRDT storage
        }
        
        Ok(())
    }
    
    pub async fn periodic_sync(&self) -> Result<()> {
        if let Some(ref _client) = self.client {
            if let Some(ref syncd) = self.config.syncd {
                if let Some(ref server_url) = syncd.url {
                    // TODO: Sync pending changes to server
                    // TODO: Fetch remote changes from server
                    // TODO: Merge remote changes with local state
                    
                    println!("Would sync {} pending changes to {}", 
                        self.pending_changes.len(), server_url);
                }
            }
        }
        
        Ok(())
    }
}
</file>

<file path="crates/lst-syncd/Cargo.toml">
[package]
name = "lst-syncd"
version = "0.1.0"
description = "Background sync daemon for lst - handles encrypted CRDT sync with remote servers"
authors = ["Tommy Falkowski"]
edition = "2021"

[[bin]]
name = "lst-syncd"
path = "src/main.rs"

[dependencies]
# CLI
clap = { workspace = true }

# Async runtime
tokio = { workspace = true }

# File watching
notify = { workspace = true }

# Serialization
serde = { workspace = true }
serde_json = { workspace = true }
toml = { workspace = true }

# Utilities
uuid = { workspace = true }
chrono = { workspace = true }
anyhow = { workspace = true }
thiserror = { workspace = true }
dirs = { workspace = true }

# HTTP client
reqwest = { workspace = true }

# Encryption (for future CRDT encryption)
# ring = "0.17"

# Internal dependencies
lst-proto = { path = "../lst-proto" }
lst-cli = { path = "../lst-cli" }
</file>

<file path="examples/lst.toml">
# Unified lst configuration file
# This file should be placed at ~/.config/lst/lst.toml
# All lst components (CLI, server, syncd) read from this single file

# ===== CLI Configuration =====
[server]
# URL of the sync server API (required for syncing)
url = "https://lists.example.com/api"
# Authentication token (obtained via magic link flow)
auth_token = "your-auth-token"
# Server host/interface to bind to (server only)
host = "127.0.0.1"
# Server port to listen on (server only)
port = 3000

[ui]
# Order in which to try different methods when resolving item targets
# Valid values: "anchor", "exact", "fuzzy", "index", "interactive"
resolution_order = ["anchor", "exact", "fuzzy", "index", "interactive"]

[fuzzy]
# Similarity threshold for fuzzy matching (0.0 to 1.0)
# Higher values require closer matches
threshold = 0.75
# Maximum number of suggestions to show in interactive mode
max_suggestions = 7

[paths]
# Base directory for all content (lists, notes, posts, media)
# Default: "./content" in current working directory
content_dir = "~/Documents/lst"
# Document kinds (e.g. ["lists", "notes", "posts"])
kinds = ["lists", "notes", "posts"]
# Subdirectory for media files under content root
# Default: "media" (relative to content_dir)
media_dir = "media"

# ===== Server Configuration =====
# [email]
# SMTP relay settings for sending login emails (server only)
# If this section is commented out or missing, login links will be logged to stdout
# smtp_host = "smtp.example.com"
# smtp_user = "your-smtp-user"
# smtp_pass = "${SMTP_PASSWORD}"  # Environment variable
# sender = "noreply@example.com"

# ===== Sync Daemon Configuration =====
[syncd]
# Server URL for remote sync (syncd only) - if None, runs in local-only mode
url = "https://lists.example.com/api"
# Authentication token for server (syncd only)
auth_token = "your-auth-token"
# Device identifier (syncd only) - auto-generated if missing
# device_id = "auto-generated-uuid"

[sync]
# Sync interval in seconds (syncd only)
interval_seconds = 30
# Maximum file size to sync in bytes (syncd only)
max_file_size = 10485760  # 10MB
# File patterns to exclude from sync (syncd only)
exclude_patterns = [".*", "*.tmp", "*.swp"]

[storage]
# CRDT storage settings (syncd only)
crdt_dir = "~/.config/lst/crdt"
# Maximum number of CRDT snapshots to keep (syncd only)
max_snapshots = 100
</file>

<file path=".gitignore">
.opencode/
/target
</file>

<file path="crates/lst-cli/src/config.rs">
use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::{Path, PathBuf};

/// Configuration for the lst application
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Config {
    #[serde(default)]
    pub ui: UiConfig,
    #[serde(default)]
    pub fuzzy: FuzzyConfig,
    #[serde(default)]
    pub paths: PathsConfig,
    #[serde(default)]
    pub server: ServerConfig,
    // Syncd-specific configuration (optional)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub syncd: Option<SyncdConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<StorageConfig>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sync: Option<SyncSettings>,
}


#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UiConfig {
    #[serde(default = "default_resolution_order")]
    pub resolution_order: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FuzzyConfig {
    #[serde(default = "default_threshold")]
    pub threshold: f32,
    #[serde(default = "default_max_suggestions")]
    pub max_suggestions: usize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PathsConfig {
    pub content_dir: Option<PathBuf>,
    pub media_dir: Option<PathBuf>,
    pub kinds: Option<Vec<String>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServerConfig {
    pub url: Option<String>,
    pub auth_token: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SyncdConfig {
    /// Server URL (if None, runs in local-only mode)
    pub url: Option<String>,
    
    /// Authentication token for server
    pub auth_token: Option<String>,
    
    /// Device identifier (auto-generated if missing)
    pub device_id: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StorageConfig {
    /// Directory for CRDT state storage
    pub crdt_dir: PathBuf,
    
    /// Maximum number of CRDT snapshots to keep
    #[serde(default = "default_max_snapshots")]
    pub max_snapshots: usize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SyncSettings {
    /// Sync interval in seconds
    #[serde(default = "default_sync_interval")]
    pub interval_seconds: u64,
    
    /// Maximum file size to sync (in bytes)
    #[serde(default = "default_max_file_size")]
    pub max_file_size: u64,
    
    /// File patterns to exclude from sync
    #[serde(default)]
    pub exclude_patterns: Vec<String>,
}

fn default_sync_interval() -> u64 {
    30 // 30 seconds
}

fn default_max_file_size() -> u64 {
    10 * 1024 * 1024 // 10MB
}

fn default_max_snapshots() -> usize {
    100
}

impl Default for Config {
    fn default() -> Self {
        Self {
            ui: UiConfig {
                resolution_order: default_resolution_order(),
            },
            fuzzy: FuzzyConfig {
                threshold: default_threshold(),
                max_suggestions: default_max_suggestions(),
            },
            paths: PathsConfig {
                content_dir: None,
                media_dir: None,
                kinds: None,
            },
            server: ServerConfig::default(),
            syncd: None,
            storage: None,
            sync: None,
        }
    }
}

impl Default for UiConfig {
    fn default() -> Self {
        Self {
            resolution_order: default_resolution_order(),
        }
    }
}

impl Default for FuzzyConfig {
    fn default() -> Self {
        Self {
            threshold: default_threshold(),
            max_suggestions: default_max_suggestions(),
        }
    }
}

impl Default for PathsConfig {
    fn default() -> Self {
        Self {
            content_dir: None,
            media_dir: None,
            kinds: None,
        }
    }
}

impl Default for ServerConfig {
    fn default() -> Self {
        Self {
            url: None,
            auth_token: None,
        }
    }
}


fn default_resolution_order() -> Vec<String> {
    vec![
        "anchor".to_string(),
        "exact".to_string(),
        "fuzzy".to_string(),
        "index".to_string(),
        "interactive".to_string(),
    ]
}

fn default_threshold() -> f32 {
    0.75
}

fn default_max_suggestions() -> usize {
    7
}

impl Config {
    /// Load configuration from the default location
    pub fn load() -> Result<Self> {
        // Check if config path is specified via environment variable
        if let Ok(custom_path) = std::env::var("LST_CONFIG") {
            return Self::load_from(&PathBuf::from(custom_path));
        }
        // Always use ~/.config/lst/ regardless of platform
        let home_dir = dirs::home_dir().context("Could not determine home directory")?;
        let config_dir = home_dir.join(".config").join("lst");
        let config_path = config_dir.join("lst.toml");
        if !config_path.exists() {
            // Create default config if it doesn't exist
            fs::create_dir_all(&config_dir).context("Failed to create config directory")?;
            let default_config = Self::default();
            let toml_str = toml::to_string_pretty(&default_config)
                .context("Failed to serialize default config")?;
            fs::write(&config_path, toml_str).context("Failed to write default config file")?;
            return Ok(default_config);
        }
        Self::load_from(&config_path)
    }

    /// Load configuration from a specific path
    pub fn load_from(path: &Path) -> Result<Self> {
        let content = fs::read_to_string(path)
            .with_context(|| format!("Failed to read config file: {}", path.display()))?;

        let config: Self = toml::from_str(&content)
            .with_context(|| format!("Failed to parse config file: {}", path.display()))?;

        Ok(config)
    }

    /// Save configuration to the default location
    pub fn save(&self) -> Result<()> {
        // Always use ~/.config/lst/ regardless of platform
        let home_dir = dirs::home_dir().context("Could not determine home directory")?;
        let config_dir = home_dir.join(".config").join("lst");
        fs::create_dir_all(&config_dir).context("Failed to create config directory")?;
        let config_path = config_dir.join("lst.toml");
        let toml_str = toml::to_string_pretty(self).context("Failed to serialize config")?;
        fs::write(&config_path, toml_str).context("Failed to write config file")?;
        Ok(())
    }

    /// Get the content directory, using default if not configured
    pub fn get_content_dir(&self) -> PathBuf {
        if let Some(ref content_dir) = self.paths.content_dir {
            content_dir.clone()
        } else {
            // Default content directory
            let home_dir = dirs::home_dir().expect("Cannot determine home directory");
            home_dir.join("lst").join("content")
        }
    }

    /// Initialize syncd configuration with defaults
    pub fn init_syncd(&mut self) -> Result<()> {
        if self.syncd.is_none() {
            let crdt_dir = dirs::config_dir()
                .context("Cannot determine config directory")?
                .join("lst")
                .join("crdt");
            
            self.syncd = Some(SyncdConfig {
                url: None,
                auth_token: None,
                device_id: Some(uuid::Uuid::new_v4().to_string()),
            });
            
            self.storage = Some(StorageConfig {
                crdt_dir,
                max_snapshots: default_max_snapshots(),
            });
            
            self.sync = Some(SyncSettings {
                interval_seconds: default_sync_interval(),
                max_file_size: default_max_file_size(),
                exclude_patterns: vec![
                    ".*".to_string(),
                    "*.tmp".to_string(),
                    "*.swp".to_string(),
                ],
            });
        }
        Ok(())
    }
}

// Global cached configuration: loaded once on first access
lazy_static::lazy_static! {
    static ref GLOBAL_CONFIG: Config = Config::load().expect("Failed to load config");
}

/// Get the global cached configuration
pub fn get_config() -> &'static Config {
    &GLOBAL_CONFIG
}
</file>

<file path="SPEC.md">
# lst - personal lists & notes App  Specification v0.4

## 1  Scope & Guiding Principles

| Principle                       | Manifestation                                                                             |
| ------------------------------- | ----------------------------------------------------------------------------------------- |
| **Plaintext ownership**        | Everything is Markdown you can open in Neovim.                                            |
| **One core, many surfaces**     | `lst` CLI, slim desktop GUI, mobile apps, Apple Shortcuts, AGNO voice agent, public blog. |
| **Offlinefirst / Selfhosted** | Single Rust server in a Proxmox LXC; sync is opportunistic; you own the data.             |
| **Extensible "document kinds"** | _lists_, _notes_, _posts_ share storage & auth.                                           |

---

## 2  HighLevel Architecture

```mermaid
graph TD
    subgraph Clients
        CLI["lst (Rust)"]
        GUI["Tauri slim GUI"]
        Mobile["Tauri 2 mobile"]
        Shortcuts["Apple Shortcuts / AppIntents"]
        Voice["AGNO agent"]
    end

    CLI --> API
    GUI --> API
    Mobile --> API
    Shortcuts --> API
    Voice --> API

    subgraph Server (LXC)
        API["Core API (Axum)"]
        Sync["CRDT + Git Store"]
        Mail["SMTP relay"]
        Build["Zola static build"]
    end

    API --|file events| Sync
    Sync --|publish posts| Build
```

---

## Authentication & Login

### Passwordless, Human-Friendly Token Auth

- Users authenticate by requesting a login code to their email address.
    - API call: `POST /auth/request` with their email.
    - Server generates a **human-readable, short-lived token** (e.g. `PLUM-FIRE-BIRD-7182`).
    - Server also generates a **QR code** that encodes a login URL (e.g. `lst-login://host/auth/verify?token=TOKEN&email=EMAIL`).
        - The domain/server is included, enabling true one-step login on mobile.
    - The token, QR (as base64 PNG), and login URL are returned in the API response.
- User enters or scans this code in their client (CLI, GUI, or mobile app).
    - API call: `POST /auth/verify` with email and token, or follows the encoded URL if scanned.
    - If the token is valid and unexpired, the server returns a JWT/session for further API use.
- All tokens are one-time and expire after ~15 minutes.
- No server-stored plaintext passwords; user authentication is ephemeral by design.

**This login flow is inspired by [Atuin](https://github.com/atuinsh/atuin): QR code onboarding encodes a login URL so users can scan and securely add a new device in a single step. Manual token entry is always supported as fallback.**

---

## 3  Storage Model

```
content/
 lists/                    # perline anchors
    groceries.md
 notes/                    # wholefile merge
    bicycleideas.md
 posts/                    # blog, Zolacompatible
    20250422firstride.md
 media/                    # images & binary files
     6fc9e6e2b4d3.jpg      # originals
     6fc9e6e2b4d3@512.webp # thumbnails
```

### 3.1 File formats

- **Lists**  bullet lines end with two spaces + `^abc12`; optional YAML frontmatter.
- **Notes**  optional frontmatter (`id`, `title`, `tags`).
- **Posts**  mandatory frontmatter (`id`, `title`, `date`, `draft`, `tags`, `summary`).
- **Media**  binary files named with SHA-256 hash of content; referenced in Markdown via relative paths.

---

## 4  Sync Logic & Merging

| Kind              | Diff unit | Technique                                   |
| ----------------- | --------- | ------------------------------------------- |
| **lists**         | line      | Automerge CRDT patches                      |
| **notes / posts** | file      | threeway Git merge; manual fix on conflict |
| **media**         | file      | Git LFS for files up to ~50MB               |

Anchors survive reordering; missing anchors are added automatically (background sync or Neovim Lua autocmd).

---

## 5  Authentication & Email Delivery

- **Magiclink flow**  15 min TTL, single use.
- **SMTP Relay**  default path (Mailgun/Postmark/SES). Configure in `server.toml`:

```toml
[email]
smtp_host = "smtp.mailgun.org"
smtp_user = "postmaster@mg.example.com"
smtp_pass = "${SMTP_PASS}"
sender    = "Lists Bot <noreply@mg.example.com>"
```

- Rust crate `lettre`  0.11 handles async SMTP; if SMTP unset, login link is logged for dev.

---

## 6  CLI **`lst`**

```
$ lst help
Usage: lst <command> 

Core  lists
  lst ls                        # list all lists
  lst add   <list> <text>       # add bullet
  lst done  <list> <target>     # mark done (anchor, fuzzy text, or #index)
  lst pipe  <list>              # read items from STDIN

Notes
  lst note new <title>
  lst note add <title> <text>
  lst note open <title>

Posts
  lst post new "<title>"
  lst post list
  lst post publish <slug>

Media
  lst img add <file> --to <doc> # add image to document
  lst img paste --to <doc>      # paste clipboard image
  lst img list <doc>            # list images in document
  lst img rm <doc> <hash>       # remove image reference
```

All commands accept `--json` for automation and return scriptfriendly exit codes.

### 6.1 Target Resolution Rules

When using commands like `lst done` that operate on a specific item, the target can be specified in several ways:

1. **Exact anchor**  `^[-A-Za-z0-9]{4,}` matches directly against the anchor ID
2. **Exact text**  Case-insensitive match against the item text
3. **Fuzzy text**  Levenshtein distance 2 or contains all words in any order
4. **Numeric index**  `#12` refers to the 12th visible bullet in the list
5. **Interactive picker**  If none of the above resolve uniquely and STDIN is a TTY, presents an interactive selection

Examples:
```bash
lst done groceries oat         # fuzzy  matches "oat milk (x2)"
lst done groceries "#4"        # by index (the 4th unchecked item)
lst done groceries ^d3e1       # explicit anchor (still works)
```

---

## 7  Client Applications

| Surface              | Highlights                                                                      |
| -------------------- | ------------------------------------------------------------------------------- |
| **Slim GUI (Tauri)** | toggleable, alwaysontop; Markdown viewer/editor; sync status tray icon.       |
| **Mobile (Tauri 2)** | offline SQLite cache  CRDT; sharesheet "Add to list"; AppIntents.             |
| **Shortcuts**        | Intents: _AddItem, RemoveItem, GetList, DraftPost_.                             |
| **Voice (AGNO)**     | Whisper transcription  AGNO agent  JSON action (`kind`, `action`, `payload`). |

---

## 8  Blog Publishing Pipeline

1. `lst post publish <slug>` flips `draft:false`.
2. Server runs `zola build`  `public/`.
3. Reverse proxy serves `/blog/*` static or optionally pushes to GitHub Pages.

---

## 9  Deployment Recipe (Proxmox LXC)

```bash
# host
pct create 120 debian-12 --cores 2 --memory 1024 --net0 name=eth0,bridge=vmbr0,ip=dhcp
pct start 120

# inside LXC
apt install ca-certificates tzdata
useradd -r -m lst
mkdir /opt/lst && chown lst /opt/lst
# copy single static binary + content/ + server.toml
systemctl enable --now lst.service  # /opt/lst/lst --config /opt/lst/server.toml
```

Proxy with Caddy/Traefik for HTTPS and path routing.

---

## 10  Configuration

### 10.1 Server Configuration

Server is configured via `/opt/lst/server.toml`:

```toml
[server]
host = "127.0.0.1"
port = 3000

[email]
smtp_host = "smtp.mailgun.org"
smtp_user = "postmaster@mg.example.com"
smtp_pass = "${SMTP_PASS}"
sender    = "Lists Bot <no-reply@mg.example.com>"

[content]
root = "content"
kinds = ["lists", "notes", "posts"]
media_dir = "media"
```

### 10.2 Client Configuration

Client is configured via:

- Linux/macOS: `${XDG_CONFIG_HOME:-$HOME/.config}/lst/lst.toml`
- Windows: `%APPDATA%\lst\lst.toml`

```toml
[server]
url = "https://lists.example.com/api"
auth_token = "..." # obtained via magic link flow

[ui]
# default order tried when resolving an item
resolution_order = ["anchor", "exact", "fuzzy", "index", "interactive"]

[fuzzy]
threshold = 0.75          # 0-1 similarity
max_suggestions = 7

[paths]
media_dir = "~/Documents/lst/media"   # override default
```

Environment override: `LST_CONFIG=/path/to/custom.toml`

---

## 11  Roadmap Snapshot

| Phase                 | Duration | Deliverables                                           |
| --------------------- | -------- | ------------------------------------------------------ |
| **MVP 0.3.1**         | 6 w      | Core server, `lst` CLI (lists), mobile/GUI readonly   |
| **Offline + CRDT**    | 4 w      | conflictfree lists across devices                     |
| **Notes & Posts**     | 3 w      | new storage kinds; `lst note` & `lst post`; Zola build |
| **Media Support**     | 2 w      | Image upload, CLI paste, Git LFS backend              |
| **Voice & Shortcuts** | 3 w      | AGNO transcription; App Intents                        |
| **Hardening**         | 2 w      | E2E encryption, invite links, CI, docs                 |

---

## Open Threads

- Set up SMTP provider & DNS (SPF/DKIM).
- Decide if Zola build stays onprem or pushes to CDN.
- Future document kinds? (journal, code snippets, etc.)

---

## Version History

+ **v0.4** (2025-04-27): Added `lst note add` command for appending text to notes
+ **v0.3** (2025-04-27): Removed `post` commands and spec entries for posts
+ **v0.2** (2025-04-25): Added notes commands (`lst note new` & `lst note open`)
+ **v0.1** (2025-04-20): Initial specification
</file>

<file path="Cargo.toml">
[workspace]
members = [
    "crates/lst-cli",
    "crates/lst-proto", 
    "crates/lst-server",
    "crates/lst-syncd",
]
resolver = "2"

[workspace.dependencies]
# CLI
clap = { version = "4.5.3", features = ["derive"] }
colored = "2.1.0"
dialoguer = "0.11.0"
console = "0.15.8"

# Storage & sync
serde = { version = "1.0.197", features = ["derive"] }
serde_yaml = "0.9.33"
serde_json = "1.0.114"
toml = "0.8.10"
dirs = "5.0.1"
uuid = { version = "1.7.0", features = ["v4", "serde"] }

# Error handling
anyhow = "1.0.81"
thiserror = "1.0.57"

# Utilities
chrono = { version = "0.4.34", features = ["serde"] }
regex = "1.10.4"
lazy_static = "1.4.0"
rand = "0.8.5"
axum = "0.8.3"
hyper = "1.6.0"
tokio = { version = "1.44.2", features = ["full"] }
qrcode = "0.14.1"
image = "0.25.6"
base64 = "0.22.1"
jsonwebtoken = "9.3.1"
urlencoding = "2.1.3"
lettre = { version = "0.11.6", features = [
  "tokio1",
  "tokio1-native-tls",
  "smtp-transport",
] }
reqwest = { version = "0.11", features = ["json"] }
notify = "6.1.1"
</file>

<file path="README.md">
# lst - Personal Lists & Notes App

`lst` is a personal lists, notes, and blog posts management application with a focus on plain-text storage, offline-first functionality, and multi-device synchronization.

## Installation

For a step-by-step guide see [docs/INSTALL.md](docs/INSTALL.md).

### From Source

```bash
git clone https://github.com/yourusername/lst.git
cd lst
cargo install --path .
```

## Features

- Manage to-do lists from the command line
- Store everything as plain Markdown files
- Work offline, sync when connected
- Fuzzy matching for item targeting
- Supports multiple document types: lists, notes, and blog posts

## Usage

### Lists

```bash
# List all lists
lst ls

# View a specific list
lst ls <list_name>

# Add an item to a list (creates the list if it doesn't exist)
lst add <list_name> "<item_text>"

# Mark an item as done (by text, fuzzy matching, or index)
lst done <list_name> "<item_text>"  # Text match
lst done <list_name> "<partial_text>"  # Fuzzy match
lst done <list_name> "#2"  # By index (the second item)

# Read items from stdin
cat items.txt | lst pipe <list_name>
```

### Notes

```bash
# Create a new note
lst note new "<title>"

# Append text to a note (creates note if missing)
lst note add "<title>" "<text>"

# Open a note in your editor
lst note open "<title>"
```
  
### Posts (Coming Soon)
```bash
# Create a new blog post
lst post new "<title>"

# Publish a blog post
lst post publish <slug>
```

### Media Support (Coming Soon)

```bash
# Add an image to a document
lst img add <file.jpg> --to <document> [--caption "Optional caption"]

# Paste image from clipboard
lst img paste --to <document> [--caption "Optional caption"]
```

## Configuration

`lst` uses a unified TOML configuration file located at `~/.config/lst/lst.toml` that is shared across all components (CLI, server, sync daemon). You can override the config file location by setting the `LST_CONFIG` environment variable.

Configuration changes take effect the next time you run a command. If you change the `content_dir` option, existing data will remain in the old location, and you'll need to move it manually to the new location.

### Configuration Options

#### CLI & Server Configuration

```toml
[server]
# URL of the sync server API (CLI) / Server host & port (server only)
url = "https://lists.example.com/api"
auth_token = "your-auth-token"
host = "127.0.0.1"  # server only
port = 3000         # server only
```

#### Sync Daemon Configuration

```toml
[syncd]
# Server URL for remote sync (if None, runs in local-only mode)
url = "https://lists.example.com/api"
auth_token = "your-auth-token"
# device_id is auto-generated on first startup
```

#### User Interface Configuration

```toml
[ui]
# Order in which to try different methods when resolving item targets
# Valid values: "anchor", "exact", "fuzzy", "index", "interactive"
resolution_order = ["anchor", "exact", "fuzzy", "index", "interactive"]
```

#### Fuzzy Matching Configuration

```toml
[fuzzy]
# Similarity threshold for fuzzy matching (0.0 to 1.0)
# Higher values require closer matches
threshold = 0.75

# Maximum number of suggestions to show in interactive mode
max_suggestions = 7
```

#### Path Configuration

```toml
[paths]
# Base directory for all content (lists, notes, posts, media)
# Default: current working directory
content_dir = "~/Documents/lst"

# Override the media directory location (relative to content_dir)
# Default: "$content_dir/media"
media_dir = "~/Documents/lst/media"
```

#### Server-Only Configuration

```toml
[email]
# SMTP relay settings (optional - if missing, login links logged to stdout)
smtp_host = "smtp.example.com"
smtp_user = "your-smtp-user"
smtp_pass = "${SMTP_PASSWORD}"  # Environment variable
sender = "noreply@example.com"

[content]
# Content directory layout (server only)
root = "~/Documents/lst"
kinds = ["lists", "notes", "posts"]
media_dir = "media"
```

#### Sync Daemon-Only Configuration

```toml
[sync]
# Sync behavior settings
interval_seconds = 30
max_file_size = 10485760  # 10MB
exclude_patterns = [".*", "*.tmp", "*.swp"]

[storage]
# CRDT storage settings
crdt_dir = "~/.config/lst/crdt"
max_snapshots = 100
```

## Example Configuration

An example unified configuration file is provided in the `examples/lst.toml` file in the repository. You can copy this file to `~/.config/lst/lst.toml` and customize it to your needs. Each component reads only the sections it needs from the same file.

## Storage Format

All data is stored as Markdown files in the content directory (which can be configured in `lst.toml`):

```
content/
 lists/                    # per-line anchors
    groceries.md
 notes/                    # whole-file merge
    bicycle-ideas.md
 posts/                    # blog, Zola-compatible
    2025-04-22-first-ride.md
 media/                    # images & binary files
     6fc9e6e2b4d3.jpg      # originals
     6fc9e6e2b4d3@512.webp # thumbnails
```

### File Format Examples

#### Lists

```markdown
---
id: 4a2e00bf-5842-4bff-8487-b9672413f0b6
title: groceries
sharing: []
updated: 2025-04-21T07:35:51.705060Z
---

- [ ] Milk  ^XMuD1
- [x] Bread  ^lkJzl
- [ ] Eggs  ^w5Cdq
```

## License

This project is licensed under the MIT License - see the LICENSE file for details.

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.
  
## Project Architecture

The `lst` project follows a layered architecture with clear separation of concerns:

### Core Architecture Layers

1. **Models Layer** (`models/`)
   - Contains core data structures like `List`, `ListItem`, etc.
   - Defines the domain objects without any I/O operations
   - Provides basic operations on in-memory objects

2. **Storage Layer** (`storage/`)
   - Handles persistence of model objects to disk (markdown files)
   - Provides higher-level operations that combine model operations with file I/O
   - Organized by storage format (markdown.rs, notes.rs)

3. **CLI Layer** (`cli/`)
   - Handles command-line parsing and user interaction
   - Connects user commands to storage operations

4. **Configuration Layer** (`config/`)
   - Manages application settings and paths
   - Provides utility functions for finding content directories

5. **Server Layer** (`server/`)
   - Implements a REST API for accessing the data
   - Separate executable from the CLI

### Flow of Control

A typical command flow:

1. User enters a command like `lst done my-list item1`
2. `main.rs` parses this using `clap` and dispatches to `cli::commands::mark_done`
3. `cli::commands::mark_done` normalizes the list name and calls `storage::markdown::mark_done`
4. `storage::markdown::mark_done` loads the list from disk, modifies it, and saves it back

This architecture provides:
- **Separation of Concerns**: Each module has a distinct responsibility
- **Testability**: Core logic can be tested without I/O dependencies
- **Flexibility**: Multiple interfaces (CLI, server) can use the same storage and model logic

## Performance

The `lst` CLI is implemented in Rust, and debug builds (e.g., those under `target/debug`) can exhibit noticeable startup latency.
For the fastest experience, use the optimized release build:
```bash
# Install the release binary to your Cargo bin directory
cargo install --path .
```
This builds with release optimizations and should start up in just a few milliseconds.

If you prefer to build locally without installing, you can:
```bash
# Build and run the release binary
cargo build --release
./target/release/lst ls <list_name>
```
</file>

<file path="TODO.md">
# TODO List for lst Project

## Core Infrastructure

- [x] Set up Rust project structure with Cargo
- [x] Create basic command-line interface structure
- [x] Implement core storage model for content directories
- [x] Create file format parsers for lists
- [x] Implement anchor generation and tracking
- [x] Convert project to a Cargo workspace
- [x] Create `lst-proto` crate for shared wire types
- [x] Implement CRDT-based sync daemon (`lst-syncd`)
- [ ] Implement WebSocket relay server (`lst-sync-srv`)
- [ ] Create file format parsers for notes and posts
- [ ] Set up Git-based three-way merge for notes/posts

## Server Components

- [x] Build Axum API server
- [x] Implement authentication via human-friendly and QR passwordless login tokens (inspired by Atuin)
- [ ] Set up SMTP email delivery with lettre
- [ ] Add WebSocket relay endpoint for sync
- [ ] Persist encrypted blobs using sled or flat files
- [ ] Create CRDT + Git storage backend
- [ ] Build Zola static site generation pipeline
- [ ] Configure server deployment for Proxmox LXC
- [ ] Set up reverse proxy configuration

## CLI Implementation (`lst`)

- [x] Implement `lst ls` command
- [x] Implement `lst add <list> <text>` command
- [x] Implement `lst done <list> <target>` command with fuzzy matching
- [x] Implement `lst pipe <list>` command
- [x] Add `--json` output option for all commands
- [x] Implement note commands (`note new`, `note add`, `note open`)
- [ ] Implement post commands (`post new`, `post list`, `post publish`)
- [ ] Implement image commands (`img add`, `img paste`, `img list`, `img rm`)
- [ ] Add `share` and `unshare` commands to manage document members via `lst-syncd`

## Client Applications

- [ ] Build Tauri slim GUI
  - [ ] Create toggleable, always-on-top window
  - [ ] Implement Markdown viewer/editor
  - [ ] Add sync status tray icon
- [ ] Develop Tauri 2 mobile app
  - [ ] Implement offline SQLite cache with CRDT sync
  - [ ] Add share-sheet "Add to list" functionality
  - [ ] Create AppIntents integration
- [ ] Build Apple Shortcuts integration
  - [ ] Implement AddItem, RemoveItem intents
  - [ ] Implement GetList, DraftPost intents
- [ ] Develop AGNO voice agent
  - [ ] Integrate Whisper transcription
  - [ ] Create AGNO agent for natural language processing
  - [ ] Implement JSON action interface

## Configuration & Infrastructure

- [x] Implement configuration loading from `~/.config/lst/lst.toml`
- [x] Unified configuration system across all components
- [x] Auto-generate device_id for syncd on first startup
- [x] Separate CLI and syncd server configurations

## Next Immediate Tasks

- [x] Implement note commands
- [ ] Improve error handling and user feedback
- [ ] Add tests for core functionality
- [ ] Implement image support with Git LFS
- [x] Convert project into a Cargo workspace
- [x] Scaffold `lst-syncd` daemon with file watching
- [ ] Scaffold `lst-sync-srv` relay with WebSocket support
- [ ] Implement simple XChaCha20 encryption and Ed25519 signing
- [ ] Persist CRDT state in sled and handle membership changes

## DevOps

- [ ] Create systemd service file for server
- [ ] Create systemd service file for sync daemon
- [ ] Set up Proxmox LXC deployment scripts
- [ ] Configure DNS for email (SPF/DKIM)
- [ ] Decide on Zola deployment strategy (on-prem vs CDN)
- [ ] Implement E2E encryption
- [ ] Create invite link system
- [ ] Set up CI pipeline

## Documentation

- [x] Create initial SPEC.md
- [ ] Write installation guide
- [ ] Create user documentation
- [ ] Document API endpoints
- [ ] Write developer documentation
- [ ] Document file formats and schemas
- [ ] Create architecture diagrams
</file>

</files>
